<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java | JyBlog🏀🐓</title><meta name="author" content="Jybzzz"><meta name="copyright" content="Jybzzz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础语法注释 单行注释： 1&#x2F;&#x2F;这是单行注释  多行注释： 12&#x2F;*这是一个多行注释*&#x2F;  文档注释： 12&#x2F;**这是文档注释*&#x2F;  命名 Java 是大小写敏感的 类名：类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写 变量名、方法名、包名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写 常量：所有字母都大写 所有标识符都应该以：字">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://blog.jybzzz.cc/2024/04/29/Java%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="JyBlog🏀🐓">
<meta property="og:description" content="基础语法注释 单行注释： 1&#x2F;&#x2F;这是单行注释  多行注释： 12&#x2F;*这是一个多行注释*&#x2F;  文档注释： 12&#x2F;**这是文档注释*&#x2F;  命名 Java 是大小写敏感的 类名：类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写 变量名、方法名、包名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写 常量：所有字母都大写 所有标识符都应该以：字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.jybzzz.cc/assets/%E8%B7%AF%E9%A3%9E4.jpg">
<meta property="article:published_time" content="2024-04-29T08:00:35.530Z">
<meta property="article:modified_time" content="2022-04-28T16:00:00.000Z">
<meta property="article:author" content="Jybzzz">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.jybzzz.cc/assets/%E8%B7%AF%E9%A3%9E4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.jybzzz.cc/2024/04/29/Java%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-29 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/%E8%B7%AF%E9%A3%9E.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list:hide"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/assets/%E8%B7%AF%E9%A3%9E4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="JyBlog🏀🐓"><span class="site-name">JyBlog🏀🐓</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list:hide"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-29T08:00:35.530Z" title="发表于 2024-04-29 16:00:35">2024-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-28T16:00:00.000Z" title="更新于 2022-04-29 00:00:00">2022-04-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><p>单行注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是单行注释</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个</span></span><br><span class="line"><span class="comment">多行注释*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文档注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**这是</span></span><br><span class="line"><span class="comment">文档注释*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul>
<li>Java 是大小写敏感的</li>
<li>类名：类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写</li>
<li>变量名、方法名、包名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写</li>
<li>常量：所有字母都大写</li>
<li>所有标识符都应该以：字母、美元符或下划线开始。关键字不能用作标识符</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul>
<li>访问控制修饰符 : public , protected, default, private<ul>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">当前类</th>
<th align="left">同一包内</th>
<th align="left">子孙类(同一包)</th>
<th align="left">子孙类(不同包)</th>
<th align="left">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>default</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left">Y</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
</tbody></table>
<ul>
<li>非访问控制修饰符 : final, abstract, static, synchronized，transient，volatile</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符</p>
<ul>
<li>+、-、*、&#x2F;、%、++、–</li>
</ul>
<p>关系运算符</p>
<ul>
<li>&#x3D;&#x3D;、!&#x3D;、＞、＜、＞&#x3D;、＜&#x3D;</li>
</ul>
<p>位运算符</p>
<ul>
<li>&amp;、|、^、~、》、《<ul>
<li>&amp;：如果相对应位都是1，则结果为1，否则为0</li>
<li>|：如果相对应位都是 0，则结果为 0，否则为 1</li>
<li>^：如果相对应位值相同，则结果为0，否则为1</li>
<li>~：按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</li>
<li>》：按位右移运算符。左操作数按位右移右操作数指定的位数</li>
<li>《：按位左移运算符。左操作数按位左移右操作数指定的位数</li>
</ul>
</li>
</ul>
<p>逻辑运算符</p>
<ul>
<li>&amp;&amp;、||、！</li>
</ul>
<p>赋值运算符</p>
<ul>
<li>&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、（%）&#x3D;、《&#x3D;、》&#x3D;、&amp;&#x3D;、^&#x3D;、|&#x3D;</li>
</ul>
<p>条件运算符(三元运算符)</p>
<ul>
<li>格式：条件表达式？值1：值2</li>
<li>执行流程：首先计算关系表达式的值，如果为true，返回值1，如果为false，返回值2</li>
</ul>
<p>instanceof 运算符</p>
<ul>
<li>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</li>
</ul>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。<strong>无默认值</strong>、<strong>在栈内存</strong>，变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。<strong>有默认值、在堆内存</strong>，这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>内置数据类型(基本数据类型)</p>
<ul>
<li>byte：占1字节、范围是-128到127，默认值是0</li>
<li>boolean：占1字节、默认值是false</li>
<li>short：占2字节、范围是-32768到32767，默认值是0</li>
<li>char：占2字节</li>
<li>int：占4字节、范围是-2,147,483,648到2,147,483,647，默认值是0</li>
<li>float：占4字节、默认值是0.0</li>
<li>double：8字节、默认值是0.0</li>
<li>long：8字节、默认值是0</li>
<li>注意：<ul>
<li>随便写一个整数字面量默认是int类型的，如果想要当成long类型，需要在其后加l&#x2F;L</li>
<li>随便写一个小数字面量默认是double类型的，如果想要当成float类型，需要在其后加f&#x2F;F</li>
<li><strong>字符是char要用单引号’ ‘，字符串是String要用双引号” “</strong></li>
</ul>
</li>
</ul>
<p>引用数据类型</p>
<ul>
<li>类，接口，数组，String（默认值是null）</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>自动类型转换（向上转型）：类型范围小的变量可以直接赋值给类型范围大的变量<ul>
<li>注意：byte,short,char是直接转换成int类型参与运算的。</li>
<li>可以调用父类中可访问的所有成员和方法，不可以调用子类的特有成员和方法。</li>
</ul>
</li>
<li>强制类型转换（向下转型）：类型范围大的变量赋值给类型范围小的变量<ul>
<li>小数变成整数时会把小数部分丢掉</li>
<li>向下转型后，可以调用子类和父类可访问的所有成员</li>
</ul>
</li>
<li>注意：对象转型之后，属性看编译类型。方法看运行类型。</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>静态初始化数组</p>
<ul>
<li><p>定义数组的时候直接给数组赋值</p>
</li>
<li><p>定义格式第一种:数据类型[] 数组名 &#x3D; new 数据类型[]{元素1，元素2，元素3,…};</p>
</li>
<li><p>定义格式第二种（简化）:数据类型[] 数组名 &#x3D; {元素1，元素2，元素3,…};  也可以把[]放在数组名后面</p>
</li>
<li><p>列如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>动态初始化数组</p>
<ul>
<li><p>定义数组的时候只确定元素的类型和数组的长度，之后再存入具体的数据</p>
</li>
<li><p>格式:数据类型[] 数组名 &#x3D; new 数据类型[长度]</p>
</li>
<li><p>列如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr [] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<p>二维数组</p>
<ul>
<li><p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301727286.png" alt="image-20240408093849901"></p>
<p>栈内存</p>
<ul>
<li>存储<strong>局部变量</strong>，定义在方法里面的变量</li>
<li>栈内存的数据<strong>用完就释放</strong>。</li>
<li>在栈内存中<strong>保存的是堆内存空间的访问地址</strong>，栈内存会有个地址指向堆内存的地址</li>
<li>栈内存<strong>线程不共享</strong></li>
</ul>
<p>堆内存</p>
<ul>
<li><p>存储<strong>new出来的的内容</strong>（实体，对象）数组在初始化时，会<strong>为存储空间添加默认值</strong></p>
</li>
<li><p>每一个new出来的东西都有一个地址值，使用完毕，会在垃圾站回收器空间时被回收</p>
</li>
<li><p>堆内存是<strong>线程共享</strong>的</p>
</li>
</ul>
<p>方法区</p>
<ul>
<li>它存储已被Java虚拟机加载的<strong>类信息、常量、静态变量</strong>、即时编译器编译后的代码等。</li>
<li>方法区是<strong>线程共享</strong>的</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li>JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</li>
<li>格式：&lt;数据类型&gt;</li>
<li>Java中的泛型是伪泛型</li>
</ul>
<p>泛型的好处</p>
<ul>
<li><em><strong>统一数据类型</strong></em></li>
<li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常</li>
</ul>
<p>细节</p>
<ul>
<li>泛型只能支持<em><strong>引用数据类型</strong></em>。</li>
<li>如果不写泛型，<em><strong>默认是Object类型</strong></em><ul>
<li>此时可以往集合添加任意的数据类型。</li>
<li>带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。</li>
</ul>
</li>
</ul>
<p>泛型的通配符</p>
<ul>
<li>泛型不具备继承性，但是数据具备继承性<ul>
<li>此时要想泛型可以继承，可以使用泛型的通配符</li>
<li>? extends E：表示可以传递E或者E所有的子类类型</li>
<li>? super E：表示可以传递E或者E所有的父类类型</li>
</ul>
</li>
</ul>
<p>应用场景</p>
<ul>
<li>如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。</li>
<li>如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符</li>
</ul>
<p>泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型通常写成：T、E、K、V。</span></span><br><span class="line">修饰符 class 类名&lt;类型&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;类型&gt; 返回值类型 方法名（类型 变量名）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="异常与错误"><a href="#异常与错误" class="headerlink" title="异常与错误"></a>异常与错误</h2><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301730664.png" alt="image-20231125145609247"></p>
<p>错误：由java虚拟机生成并抛出的异常，程序无法处理，通常指程序中出现的严重问题。</p>
<ul>
<li>Error（错误）是不可查的，而且也常常在应用程序的控制和处理能力之外，因此当Error（错误）出现时，程序会立即奔溃，Java虚拟机立即停止运行，</li>
</ul>
<p>异常：是指程序本身可以处理的异常（可以向上抛出或者捕获处理）。</p>
<ul>
<li>编译时异常：程序在编译过程中发现的异常，受检异常</li>
<li>运行时异常：又称非受检异常</li>
</ul>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ul>
<li>Java处理异常的默认方式是<strong>中断处理</strong>。</li>
<li>使用try、catch、finaly捕获异常后程序会继续执行；使用throws抛出的异常类型，出现异常后，程序终止</li>
</ul>
<p>自己处理（try catch finally）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//可能出现问题的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常名称)&#123;</span><br><span class="line">	<span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常名称)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>catch中声明的异常类型应该和实际抛出的异常类型要么相同要么有继承关系</p>
</li>
<li><p>try块中有多行代码，都有可能出现异常信息时，程序执行的时候是从上往下执行的，当碰到异常情况的时候就会跳出try块，从而try块中剩余的代码就不会执行了，</p>
</li>
<li><p>finally修饰的代码一定会执行（前提是异常成功进入到了相应的try catch中）</p>
<ul>
<li><p>try语句中，在执行return语句时，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，因此，即使finally中对变量x进行了改变，但是不会影响返回结果。它应该使用栈保存返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        x++;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果输出为3和2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>printStackTrace()方法可以打印出详细的异常信息</p>
</li>
</ul>
<p>将异常抛出（throws和throw）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名(参数列表) [<span class="keyword">throws</span> 异常<span class="number">1</span>，异常<span class="number">2.</span>..]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>throws关键字声明的方法表示此方法不处理异常而交给方法的调用者进行处理</li>
<li>在重写方法时，它所声明的异常范围不能被扩大</li>
<li>throws和throw的区别<ul>
<li>throws用在方法名后面，跟的是异常类名，throw是用在方法体重，跟的异常对象</li>
<li>throws可以跟多个异常类名，用逗号隔开throw只能抛出一个异常对象</li>
<li>throws表示抛出异常，由该方法的调用者来处理，throw表示抛出异常，由方法体内的语句处理</li>
</ul>
</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>​	Java中的异常都是Throwable或者Exception或者RuntimeException的子类，那么我们要创建一个自定义的异常，其实就是创建其对应的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 编写一个分数必须在0-100之间的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">0</span>||score&gt;<span class="number">100</span>)<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScoreException</span>(<span class="string">&quot;分数不可分法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (?)&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value3:</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断条件？值<span class="number">1</span>：值<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>普通for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;循环条件;迭代语句)&#123;</span><br><span class="line">            循环体语句;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>增强for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型 变量名∶数组或者collection集合)&#123;</span><br><span class="line">			循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>普通while循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do-while循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表）&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项：<ul>
<li>如果方法的返回值类型为void（无返回值），方法内则不能使用return返回数据</li>
<li>如果方法的返回值类型写了具体类型，方法内部则必须使用return返回</li>
<li>java的参数传递都是值传递</li>
<li>基本类型的参数传输存储的数据值</li>
<li>引用类型的参数传输存储的地址值</li>
</ul>
</li>
</ul>
<h2 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h2><ul>
<li>重载(overloading) 是在同一个类(或子类)里面，<em><strong>方法名字相同，参数列表不同</strong></em>；返回类型和权限修饰符可以相同也可以不同；可以抛出新的或更广的异常</li>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)</li>
</ul>
<h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><ul>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变</li>
<li>方法名、参数列表和返回类型都相同；权限修饰符要大于父类方法；不能抛出新的或者更广的异常</li>
<li>返回类型可以是父类返回值类型的子类。</li>
</ul>
<p>重写规则</p>
<ul>
<li>声明为 final 的方法不能被重写。</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>构造方法不能被重写。</li>
</ul>
<table>
<thead>
<tr>
<th>区别点</th>
<th>方法重载</th>
<th>方法重写</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td><strong>必须修改</strong></td>
<td><strong>不能修改</strong></td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>不能修改(可以是子类)</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>可以降低限制</td>
</tr>
</tbody></table>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul>
<li>当一个对象被创建时候，构造方法用来初始化该对象。</li>
<li>构造方法和它所在类的名字相同。</li>
<li>构造方法没有返回值，但可以有return，return在这里只是表示结束，并不是返回的表示。</li>
<li>默认构造方法的访问修饰符和类的访问修饰符相同</li>
<li>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法</li>
<li>一旦你定义了自己的构造方法，默认构造方法就会失效</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>类的五大成员：属性、方法、构造器、代码块、内部类</p>
<p>Java代码执行顺序：父类的静态代码块 –&gt; 子类的静态代码块 –&gt; 父类的普通代码块 –&gt; 父类的构造方法</p>
<p>–&gt; 子类的普通代码块 –&gt; 子类的构造方法</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装的概念"><a href="#封装的概念" class="headerlink" title="封装的概念"></a>封装的概念</h3><ul>
<li>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法</li>
<li>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问</li>
<li>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性</li>
<li>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段</li>
</ul>
<h3 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h3><ul>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员变量进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ul>
<h3 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h3><ul>
<li>修改属性的可见性来限制对属性的访问（一般限制为private）</li>
<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h3><ul>
<li>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</li>
<li>继承需要符合的关系是：is-a，父类更通用，子类更具体</li>
</ul>
<h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><ul>
<li>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 父类&#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul>
<li>子类拥有父类非 private 的属性、方法</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</li>
<li>子类可以用自己的方式实现父类的方法</li>
<li>Java 的继承是单继承，但是可以多重继承</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</li>
</ul>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ul>
<li>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类</li>
</ul>
<h3 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h3><ul>
<li>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li>super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类</li>
</ul>
<p>super的用法</p>
<ul>
<li>每个子类构造方法的第一条语句，都是隐含地调用 super()</li>
</ul>
<ol>
<li>普通的直接引用<ul>
<li>与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员</li>
</ul>
</li>
<li>引用构造函数<ul>
<li>super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）</li>
<li>this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）</li>
</ul>
</li>
</ol>
<h3 id="this和super的特性"><a href="#this和super的特性" class="headerlink" title="this和super的特性"></a>this和super的特性</h3><ul>
<li>均不可以在 static 环境中使用</li>
<li>this 和 super 不能同时出现在一个构造函数里面</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3><ul>
<li>多态是同一个行为具有多个不同表现形式或形态的能力</li>
<li>多态性是对象多种表现形式的体现</li>
</ul>
<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul>
<li><p>继承</p>
</li>
<li><p>重写</p>
</li>
<li><p>父类引用指向子类对象</p>
</li>
</ul>
<h3 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h3><ul>
<li>方法重写</li>
<li>接口</li>
<li>抽象类和抽象方法</li>
</ul>
<h3 id="多态中成员访问特点"><a href="#多态中成员访问特点" class="headerlink" title="多态中成员访问特点"></a>多态中成员访问特点</h3><ul>
<li>方法：编译看左边，运行看右边</li>
<li>变量：编译看左边，运行也看左边</li>
</ul>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><ul>
<li>java中的<code>static</code>关键字主要用于内存管理</li>
<li>实用范围：static可以用在变量、方法、代码块和嵌套类<ul>
<li>变量：称为类变量、静态变量</li>
<li>方法：称为类方法、静态方法</li>
<li>代码块：称为静态代码块</li>
<li>嵌套类：称为静态内部类</li>
</ul>
</li>
<li>静态成员变量和方法的访问：类名.静态成员变量&#x2F;方法(推荐)、对象.静态成员变量&#x2F;方法(不推荐)</li>
<li>特点<ul>
<li><strong>静态方法只能访问静态成员和方法，不可以“直接”访问实例成员和方法</strong></li>
<li>随着类的加载而被加载</li>
<li>优先于对象存在，被所有对象共享</li>
<li>局部变量不能被static修饰</li>
</ul>
</li>
</ul>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li><p>final是一个关键字，可以用于修饰类，成员变量，成员方法</p>
</li>
<li><p>特点</p>
<ul>
<li>它修饰的类不能被继承。</li>
<li>它修饰的成员变量是一个常量</li>
<li>它修饰的成员方法是不能被子类重写的</li>
</ul>
</li>
<li><p><strong>final修饰成员变量,必须初始化</strong></p>
</li>
<li><p>final修饰的常量定义一般都有书写规范,被final修饰的常量名称,所有字母都大写</p>
</li>
<li><p>final修饰的变量只能在显示初始化或者构造函数初始化的时候赋值一次，以后不允许更改</p>
</li>
</ul>
<h2 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h2><ul>
<li>用abstract关键字</li>
</ul>
<p>特点</p>
<ul>
<li>抽象类不能被实例化，如果被实例化，就会报错，编译无法通过</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li>
<li>抽象类中的抽象方法只是声明，不包含方法体</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</li>
<li>抽象方法不能使用private、static、final修饰</li>
</ul>
<h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><ul>
<li>用interface关键字</li>
</ul>
<p>特点</p>
<ul>
<li>接口不能用于实例化对象</li>
<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法</li>
<li>接口不能包含成员变量，除了 static 和 final 变量</li>
<li>接口不是被类继承了，而是要被类实现</li>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</li>
</ul>
<p>抽象类和接口的不同点和相同点</p>
<ul>
<li><p>相同点</p>
<ul>
<li>都不能实例化</li>
<li>子类都必须实现抽象方法</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li><p>抽象类可以有构造方法，而接口没有</p>
</li>
<li><p>抽象类可以包含普通方法和代码块，接口里只能包含抽象方法，静态方法和默认方法</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，接口的成员变量只能是 <strong>public static final</strong> 类型的，并且必须赋值</p>
</li>
<li><p>一个类只能继承一个抽象类，但可以实现多个接口</p>
</li>
<li><p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>抽象</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>组成</td>
<td>构造方法、抽象方法、普通方法、常量、变量</td>
<td>常量、抽象方法（jdk8：默认方法、静态方法）</td>
</tr>
<tr>
<td></td>
<td>is</td>
<td>like</td>
</tr>
</tbody></table>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类嵌套在另一个类里面或者一个方法里面，被嵌套的类称为内部类。</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义</p>
<ul>
<li>成员内部类是最普通的内部类，它的定义为位于另一个类的内部</li>
</ul>
<p>内访外</p>
<ul>
<li><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</p>
</li>
<li><p>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="built_in">this</span>.成员变量</span><br><span class="line">外部类.<span class="built_in">this</span>.成员方法</span><br></pre></td></tr></table></figure></li>
</ul>
<p>外访内</p>
<ul>
<li>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问，创建成员内部类的对象</li>
</ul>
<p>创建对象格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名=<span class="keyword">new</span>外部类构造器.new内部类构造器</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义</p>
<ul>
<li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</li>
</ul>
<p>内范外</p>
<ul>
<li>直接访问外部类的所有成员（包括私有成员）</li>
<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类成员，则可以使用（外部类名.this.成员）访问</li>
</ul>
<p>外访内</p>
<ul>
<li>创建对象再访问</li>
</ul>
<p>特点</p>
<ul>
<li>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的,可以使用final.</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义</p>
<ul>
<li>本质上是一个没有名字的局部内部类，定义在方法、代码块中</li>
</ul>
<p>特点</p>
<ul>
<li>匿名内部类也是不能有访问修饰符和 static 修饰符</li>
<li>大部分匿名内部类用于接口回调。</li>
<li>匿名内部类是唯一一种没有构造器的类。</li>
<li>匿名内部类可以作为方法的实际参数进行传输</li>
</ul>
<p>创建对象格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类|抽象类名|或接口名（）&#123;重写方法&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义</p>
<ul>
<li>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</li>
</ul>
<p>特点</p>
<ul>
<li>静态内部类是不需要依赖于外部类的</li>
<li>它不能使用外部类的非static成员变量或者方法</li>
</ul>
<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h2><ul>
<li>定义枚举类的格式:修饰符 enum 枚举名称{第一行都是罗列枚举类实例的名称}</li>
<li>枚举做信息标志和分类:代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术!建议使用</li>
<li>枚举类都是继承了枚举类型:java.lang.Enum</li>
<li>枚举都是最终类，不可以被继承</li>
<li>构造器的构造器都是私有的，枚举对外不能创建对象</li>
<li>枚举类的第一行默认都是罗列枚举对象的名称的</li>
<li>枚举类相当于是多例模式</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合和泛型都<strong>只能支持引用数据类型</strong>，不支持基本数据类型，所以集合中存储的元素都认为是对象</p>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><h3 id="Collection特点"><a href="#Collection特点" class="headerlink" title="Collection特点"></a>Collection特点</h3><p>Collection是<em><strong>单列</strong></em>集合的祖宗接口，它的功能是全部单列集合都可以继承使用的</p>
<p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301730101.png" alt="image-20240311202352087"></p>
<h3 id="Collection通用API"><a href="#Collection通用API" class="headerlink" title="Collection通用API"></a>Collection通用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>把给定的对象添加到当前集合中</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>清空集合中所有的元素</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>把给定的对象在当前集合中删除</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>判断当前集合中是否包含给定的对象</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>判断当前集合是否为空</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>返回集合中元素的个数。</span><br><span class="line"><span class="keyword">public</span> Object[] toArray()把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure>

<ul>
<li>remove：因为Collection里面定义的是共性的方法，所以此时不能通过索引进行删除。只能通过元素的对象进行删除。</li>
<li>cotains<ul>
<li>contains方法在底层依赖equals方法判断对象是否一致的。</li>
<li>如果存的是自定义对象，没有重写equals方j法，那么默认使用object类中的equals方法进行判断，而object类中equals方法，依赖地址值进行判断。</li>
<li>所以，需要在自定义的Javabean类中，重写equals方法就可以了。</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特点</p>
<ul>
<li>List系列集合：添加的元素是<em><strong>有序、可重复、有索引</strong></em></li>
</ul>
<p>List集合特有方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,E element)</span>在此集合中的指定位置插入指定的元素</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>删除指定索引处的元素，返回被删除的元素</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span>修改指定索引处的元素，返回被修改的元素</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>返回指定索引处的元素</span><br></pre></td></tr></table></figure>

<ul>
<li>add：添加后，原来索引处上的元素会依次往后移</li>
</ul>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>底层原理</p>
<ul>
<li>ArrayList底层是<em><strong>基于数组实现的</strong></em>，根据索引定位元素快，增删需要做元素的移位操作</li>
<li>利用空参创建的集合，在底层创建一个默认长度为0的数组，数组名为elementData</li>
<li>添加第一个元素时，底层会创建一个新的长度为<em><strong>10</strong></em>的数组</li>
<li>存满时，会扩容<em><strong>1.5</strong></em>倍</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li>
</ul>
<h4 id="LinekdList"><a href="#LinekdList" class="headerlink" title="LinekdList"></a>LinekdList</h4><p>底层原理</p>
<ul>
<li>底层数据结构是<em><strong>双向链表</strong></em>，<em><strong>查询慢，增删快</strong></em>，但是如果操作的是首尾元素，速度也是非常快的</li>
</ul>
<p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731667.png" alt="image-20240313110643515"></p>
<p>- </p>
<p>特有API</p>
<p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731222.png" alt="image-20240313110333982"></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>HashSet：<em><strong>无序、不重复、无索引</strong></em></li>
<li>TreeSet：按照大小<em><strong>默认升序排序、不重复、无索引</strong></em></li>
</ul>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><h3 id="Map特点"><a href="#Map特点" class="headerlink" title="Map特点"></a>Map特点</h3><ul>
<li>Map属于双列集合，双列集合一次需要存一对数据，分别为键和值</li>
<li>键和值是一 一对应的,每一个键只能找到自己对应的值</li>
<li>Map集合的键是<strong>不重复的，无索引</strong>的</li>
<li>键＋值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”</li>
<li>Map集合的键值对都可以为null</li>
</ul>
<p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731968.png" alt="image-20240313151307847"></p>
<h3 id="Map通用API"><a href="#Map通用API" class="headerlink" title="Map通用API"></a>Map通用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">put</span><span class="params">(K key,v value)</span>添加元素</span><br><span class="line">v <span class="title function_">remove</span><span class="params">(0bject key)</span>根据键删除键值对元素</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>移除所有的键值对元素</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(object key)</span>判断集合是否包含指定的键</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(0bject value)</span>判断集合是否包含指定的值</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>判断集合是否为空</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>集合的长度，也就是集合中键值对的个数</span><br></pre></td></tr></table></figure>

<ul>
<li>put：添加时，如果键已经存在，就会覆盖原来，并返回原理的值</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>特点</p>
<ul>
<li>元素按照键是<em><strong>无序，不重复，无索引</strong></em>的</li>
<li>HashMap跟HashSet底层原理是一模一样的，都是<em><strong>哈希表结构</strong></em>。依赖hashCode方法和equals方法保证键的唯一</li>
<li>如果键存储的是自定义对象，需要重写hashCode和equals方法如果值存储自定义对象，不需要重写hashCode和equals方法</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>特点</p>
<ul>
<li>元素按照键是<em><strong>有序，不重复，无索引</strong></em>的<ul>
<li>这里的有序指的是保证存储和取出的元素顺序一致</li>
</ul>
</li>
<li>底层数据结构是依然<em><strong>哈希表</strong></em>，只是每个键值对元素又额外的多了一个<em><strong>双链表</strong></em>的机制记录存储的顺序</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>特点</p>
<ul>
<li>TreeMap跟TreeSet底层原理一样，都是红黑树结构的。</li>
<li>元素按照键是<em><strong>不重复、无索引、可排序</strong></em>的<ul>
<li>可排序是对键进行排序。<ul>
<li>方法一：实现Comparable接口，指定比较规则。</li>
<li>方法二：</li>
<li>创建集合时传递Comparator比较器对象，指定比较规则。</li>
</ul>
</li>
<li>默认按照键的从小到大进行排序，也可以自己规定键的排序规则</li>
</ul>
</li>
</ul>
<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>遍历方式的选择</p>
<table>
<thead>
<tr>
<th>遍历方式</th>
<th>选择情况</th>
</tr>
</thead>
<tbody><tr>
<td>迭代器</td>
<td>在遍历的过程中需要<em><strong>删除</strong></em>元素，请使用迭代器。</td>
</tr>
<tr>
<td>列表迭代器</td>
<td>在遍历的过程中需要<em><strong>添加</strong></em>元素，请使用列表迭代器。</td>
</tr>
<tr>
<td>增强for循环</td>
<td>仅仅想遍历，那么使用增强for或Lambda表达式。</td>
</tr>
<tr>
<td>Lambda表达式</td>
<td>仅仅想遍历，那么使用增强for或Lambda表达式。</td>
</tr>
<tr>
<td>普通for</td>
<td>如果遍历的时候想<em><strong>操作索引</strong></em>，可以用普通for。</td>
</tr>
</tbody></table>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>特点</p>
<ul>
<li>在Java中的代表是***lterator()***，迭代器是集合的专用遍历方式</li>
<li>迭代器不依赖索引</li>
<li>迭代器就好比是一个箭头，默认指向集合的0索引处</li>
</ul>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="comment">//询问当前位置是否有元素存在，存在返回true ,不存在返回false</span></span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span> <span class="comment">//获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> <span class="comment">//删除当前获取到的元素</span></span><br></pre></td></tr></table></figure>

<p>迭代器遍历格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;集合中元素的类型&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">	集合中元素的类型 变量名 = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节和注意事项</p>
<ul>
<li>当指到最后一个位置时，如果还继续用next，就会报错NoSuchElementException</li>
<li>迭代器遍历完毕，指针不会复位循环中</li>
<li>在循环中最好不要用两个或以上次数的next方法</li>
<li>迭代器遍历时，<em><strong>不能用集合的方法</strong></em>进行增加或者删除，可以用迭代器提供的remove删除</li>
</ul>
<h4 id="增强for遍历"><a href="#增强for遍历" class="headerlink" title="增强for遍历"></a>增强for遍历</h4><p>特点</p>
<ul>
<li>增强for的底层就是迭代器，为了简化迭代器的代码书写的。</li>
<li>它是JDK5之后出现的，其内部原理就是一个lterator迭代器</li>
<li>所有的<em><strong>单列集合和数组</strong></em>才能用增强for进行遍历。</li>
</ul>
<p>增强for遍历格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合中元素的数据类型 变量名:数组或者集合)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>细节和注意事项</p>
<ul>
<li>修改增强for中的变量，不会改变集合中原本的数据。</li>
</ul>
<h4 id="Lambda表达式遍历"><a href="#Lambda表达式遍历" class="headerlink" title="Lambda表达式遍历"></a>Lambda表达式遍历</h4><p>lambda表达式特点</p>
<ul>
<li>()-&gt;{}</li>
</ul>
<p>Lambda表达式遍历格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">集合名.forEach((集合中元素的数据类型 变量名)-&gt;&#123;</span><br><span class="line">   循环体...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果循环体只有一行代码，则可以简化成以下形式</span></span><br><span class="line">集合名.forEach(变量名 -&gt; 循环体);</span><br></pre></td></tr></table></figure>

<h4 id="列表迭代器-List特有"><a href="#列表迭代器-List特有" class="headerlink" title="列表迭代器(List特有)"></a>列表迭代器(List特有)</h4><p>特点</p>
<ul>
<li>listIterator()</li>
<li>List集合特有的遍历方式</li>
</ul>
<p>特有方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span><span class="comment">//将指定元素插入列表</span></span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过keySet方法，得到一个包含所有key的单列集合</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.遍历包含键的单列集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    <span class="comment">//3.通过get方法得到键对应的值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过entrySet方法，得到一个包含所有键值对的单列集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">//2.遍历包含键值对的单列集合</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entrySet) &#123;</span><br><span class="line"><span class="comment">//3.通过getKey()、和getValue()得到对应的键和值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey()+<span class="string">&quot;:&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">	System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><ul>
<li>作用：结合了Lambda表达式，简化集合、数组的操作</li>
</ul>
<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><ul>
<li>不可变是指不能增删改，只能查</li>
</ul>
<p>不可变list集合</p>
<ul>
<li>List.of(E….elements);</li>
</ul>
<p>不可变Set集合</p>
<ul>
<li>Set.of(E….elements)</li>
<li>注意，Set是无重复的。</li>
</ul>
<p>不可变Map集合</p>
<ul>
<li>Map.of( K k1,V v1,K k2, V v2…)</li>
<li>注解，key是不能重复的</li>
<li>最多只能传20个参数，也就是10个键值对。</li>
<li>如果要传超过10个以上的键值对可以用Map.copyOf(Map map)方法，注意，此方法在jdk9之后才有</li>
</ul>
<h3 id="Stream的使用步骤"><a href="#Stream的使用步骤" class="headerlink" title="Stream的使用步骤"></a>Stream的使用步骤</h3><ol>
<li><p>先得到一条Stream流，并把数据放上去</p>
<table>
<thead>
<tr>
<th>获取方式</th>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>单列集合</td>
<td>default Stream<E> stream()</td>
<td>Collection中的默认方法</td>
</tr>
<tr>
<td>双列集合</td>
<td>无（可以用keySet和entrySet）</td>
<td>无法直接使用stream流</td>
</tr>
<tr>
<td>数组</td>
<td>public static <T> Stream<T> stream(T[]array)</td>
<td>Arrays工具类中的静态方法</td>
</tr>
<tr>
<td>一堆零散数据</td>
<td>public static<T> Stream<T> of(T…values)</td>
<td>Stream接口中的静态方法</td>
</tr>
</tbody></table>
<ul>
<li>单列集合：list.stream()</li>
<li>双列集合：map.keySet().stream()</li>
<li>数组：Arrays.stream(arr)</li>
<li>零散数据：Stream.of(T…values)</li>
</ul>
</li>
<li><p>Stream流常见的中间方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Stream<T> <strong>filter</strong>(Predicate&lt;? super T&gt; predicate)</td>
<td>过滤</td>
</tr>
<tr>
<td>Stream<T> <strong>limit</strong>(long maxSize)</td>
<td>获取前几个元素</td>
</tr>
<tr>
<td>Stream<T> <strong>skip</strong>(long n)</td>
<td>跳过前几个元素</td>
</tr>
<tr>
<td>Stream<T> <strong>distinct</strong>()</td>
<td>元素去重，依赖（hashCode和equals方法）</td>
</tr>
<tr>
<td>static <T> Stream<T> <strong>concat</strong>(Stream a, Stream b)</td>
<td>合并a和b两个流</td>
</tr>
<tr>
<td>Stream<R> <strong>map</strong>(Function&lt;T ,R&gt; mapper)</td>
<td>转换流中的数据类型</td>
</tr>
</tbody></table>
<ul>
<li>注意1：中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程</li>
<li>注意2：修改Stream流中的数据，不会影响原来集合或者数组中的数据</li>
</ul>
</li>
<li><p>Stream流的终结方法</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void <strong>forEach</strong>(Consumer action)</td>
<td>遍历</td>
</tr>
<tr>
<td>long <strong>count</strong>()</td>
<td>统计</td>
</tr>
<tr>
<td><strong>toArray</strong>()</td>
<td>收集流中的数据，放到数组中</td>
</tr>
<tr>
<td>**collect(**Collector collector)</td>
<td>收集流中的数据，放到集合中</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><ul>
<li><p>作用：获取文件本身的信息，删除文件，创建文件等功能</p>
</li>
<li><p>File类创建对象：</p>
<ul>
<li><pre><code class="java">File f = new File(pathname);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - pathname支持绝对路径（从盘符开始），也支持相对路径（不带盘符）</span><br><span class="line">  - 相对路径默认直接到当前工程下的目录寻找文件</span><br><span class="line">  - 路径用双反斜杠或斜杠/</span><br><span class="line"></span><br><span class="line">- 常用API：</span><br><span class="line"></span><br><span class="line">  - getAbsolutePath()：获取文件的绝对路径</span><br><span class="line">  - getPath()：获取文件定义时所用的路径</span><br><span class="line">  - getName()：获取文件的名称（带后缀）</span><br><span class="line">  - length()：获取文件大小（**字节**个数）</span><br><span class="line">  - lastModified()：获取文件的最后修改时间</span><br><span class="line">  - isFile()和isDirectory()：判断文件是文件还是文件夹</span><br><span class="line">  - createNewFile()：创建新文件</span><br><span class="line">  - delete()：删除文件</span><br><span class="line">  - mkdir()：创建一级目录</span><br><span class="line">  - mkdirs()：创建多级目录</span><br><span class="line">  - 常用来遍历的API：</span><br><span class="line">    - list()：获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span><br><span class="line">    - listFiles()：获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回</span><br><span class="line"></span><br><span class="line">## **IO流**</span><br><span class="line"></span><br><span class="line">- 作用：读写文件数据</span><br><span class="line">- 分为两大类：字节流和字符流</span><br><span class="line"></span><br><span class="line">### 编码和解码</span><br><span class="line"></span><br><span class="line">- 英文，数字，符号一般占1个字节</span><br><span class="line">- GBK中，中文占2个字节</span><br><span class="line">- UTF-8中，中文占3个字节</span><br><span class="line"></span><br><span class="line">- 编码</span><br><span class="line">  - str.getBytes(编码格式)：编码格式默认是utf-8，返回类型是一个byte类型的数组</span><br><span class="line">- 解码</span><br><span class="line">  - new String(bytes,解码格式)：解码格式默认是utf-8，返回类型是字符串</span><br><span class="line"></span><br><span class="line">### 字节流</span><br><span class="line"></span><br><span class="line">- 字节输入流（InputStream）</span><br><span class="line"></span><br><span class="line">  - InputStream是一个抽象类，其实现类常用FileInputStream</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    InputStream inputStream = new FileInputStream（path）;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>常用API</p>
<ul>
<li><p>read()：每次读取一个字节返回，返回的是该字节的编码，如果字节已无可读内容则返回-1</p>
</li>
<li><p>**readAllBytes()**：读取全部字节，返回的是一个byte类型的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(new String(inputStream.readAllBytes()));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>字节输出流（OutputStream）</p>
<ul>
<li><p>OutputStream是一个抽象类，其实现类常用FileOutputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path,append);</span><br></pre></td></tr></table></figure>

<ul>
<li>默认会清空之前的数据，如果想追加的话就在括号里加个true</li>
</ul>
</li>
<li><p>常用API</p>
<ul>
<li><p>write(int a)：写入一个字节</p>
</li>
<li><p>**write(byte[] bytes)**：写一个字节数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(<span class="string">&quot;卢家业呀&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：刷新数据</p>
</li>
<li><p>close()：关闭流，关闭包含刷新，关闭后流不可以继续使用了</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul>
<li><p>字符输入流（Reader）</p>
<ul>
<li><p>Reader是一个抽象类，其实现类常用FileReader</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = new FileReader(path);</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用API</p>
<ul>
<li>read()：每次读取一个字节返回，返回的是该字节的编码，如果字节已无可读内容则返回-1</li>
</ul>
</li>
</ul>
</li>
<li><p>字符输出流（Writer）</p>
<ul>
<li><p>Writer是一个抽象类，其实现类常用FileWriter</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = new FileWriter(path,append);</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用API</p>
<ul>
<li><p>write()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.write(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p>flush()：刷新数据</p>
</li>
<li><p>close()：关闭流，关闭包含刷新，关闭后流不可以继续使用了</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>进程：进程是程序的基本执行实体</li>
<li>线程：线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</li>
<li>多线程的作用：可以让程序同时做多件事情，提高运行效率</li>
<li>并发：在同一时刻，有多个指令在单个CPU上<strong>交替</strong>执行</li>
<li>并行：在同一时刻，有多个指令在多个CPU上<strong>同时</strong>执行</li>
</ul>
<h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><p>主线程应该放在子线程之后</p>
<ul>
<li><p>方式一：继承Thread类</p>
<ol>
<li>定义一个类继承Thread</li>
<li>重写run方法，里面是定义线程以后要干啥</li>
<li>创建一个该类的对象</li>
<li>调用start方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式一：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLearn</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//1.继承Thread类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//2.重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程正在输出&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLearn</span>();<span class="comment">//3.创建一个该类的对象</span></span><br><span class="line">        thread.start();<span class="comment">//4.调用start方法启动线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程正在输出&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二： 实现Runnable接口</p>
<ol>
<li>实现Runnable接口</li>
<li>重写run方法</li>
<li>创建一个该类对象</li>
<li>把该对象交给Thread线程对象处理</li>
<li>调用start方法，启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式二：实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;<span class="comment">//1.实现Runnable接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//2.重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程1正在输出&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>();<span class="comment">//3.创建一个该类的对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);<span class="comment">//4.把该对象交给Thread线程对象处理</span></span><br><span class="line">    thread1.start();<span class="comment">//5.调用start方法，启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以用匿名内部类或lambda表达式的方法来简化代码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三：实现Callable接口，结合FutureTask完成（改方法可以获取多线程运行的结果）</p>
<ol>
<li>实现Callable接口，应申明线程任务执行完毕后的结果的数据类型</li>
<li>重写call方法</li>
<li>创建该类对象</li>
<li>把该对象交给FutureTask对象</li>
<li>再把FutureTask对象交给Thread对象处理</li>
<li>调用start方法</li>
<li>可通过调用FutureTask对象的get方法获取线程执行完毕后的结果</li>
</ol>
</li>
</ul>
<p>三种实习方式对比</p>
<p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731271.png" alt="image-20231120210301967"></p>
<p>多线程的书写套路</p>
<ol>
<li>循环</li>
<li>同步代码块（同步方法）</li>
<li>判断共享数据是否到了末尾（到了末尾就break）</li>
<li>判断共享数据是否到了末尾（没到末尾就执行核心逻辑）</li>
</ol>
<h2 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h2><ul>
<li>setName(String name)：给线程命名 <ul>
<li>如果没有给线程命名，它也有默认的名字:Thread-X。</li>
<li>Thread的构造方法也可以给线程命名</li>
</ul>
</li>
<li>getName()：获取线程的名字</li>
<li>currentThread()：获取当前的线程对象</li>
<li>sleep(long time): 让线程休眠指定的时间，单位为毫秒</li>
<li>setPriority(int newPriority): 设置线程的优先级<ul>
<li>默认是5，最小是1，最大是10</li>
<li>线程的优先级越高只是会让它执行的概率变高。</li>
</ul>
</li>
<li>getPriority(): 获取线程的优先级</li>
<li>setDaemon(boolean on): 设置为守护线程<ul>
<li>当其他的非守护线程执行完毕之后，守护线程会<strong>陆续结束</strong></li>
</ul>
</li>
<li>yield(): 出让&#x2F;礼让线程<ul>
<li>尽可能的让线程交替执行</li>
</ul>
</li>
<li>join(): 插入&#x2F;插队线程<ul>
<li>让某个线程执行完后再执行其他线程</li>
</ul>
</li>
</ul>
<h2 id="线程的生命周期和安全问题"><a href="#线程的生命周期和安全问题" class="headerlink" title="线程的生命周期和安全问题"></a>线程的生命周期和安全问题</h2><p>生命周期</p>
<p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731054.png" alt="image-20231118180413483"></p>
<p>安全问题</p>
<ul>
<li>线程在执行代码的时候，cpu的执行权，随时有可能被其他线程抢走（随机性）<ul>
<li>解决方式：把操作共享数据的代码锁起来</li>
</ul>
</li>
<li>死锁问题： 一种线程间互相等待的状态，导致程序无法正常运行</li>
</ul>
<p>线程的六种状态</p>
<ul>
<li>新建：至今尚未启动的线程处于这种状态。</li>
<li>就绪start：正在Java虚拟机中执行的线程处于这种状态。</li>
<li>阻塞：受阻塞并等待某个监视器锁的线程处于这种状态。</li>
<li>无限期等待wait：无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。</li>
<li>计时等待sleep：等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。</li>
<li>结束：已退出的线程处于这种状态。</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>synchronized锁</p>
<ul>
<li><p>同步代码块</p>
<ul>
<li><p>格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;操作共享数据的代码&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>锁默认打开，有一个线程进去了,锁自动关闭</li>
<li>里面的代码全部执行完毕,线程出来,锁自动打开</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>锁对象是任意的一个对象，它一定要是唯一的</li>
</ul>
</li>
</ul>
</li>
<li><p>同步方法</p>
<ul>
<li><p>格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名 （方法参数）&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特点</p>
<ul>
<li>同步方法是锁住方法里面所有的代码</li>
<li>锁对象不能自己指定</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>非静态的方法的锁对象是this，静态的方法的锁对象是当前的字节码文件对象</li>
<li>StringBuilder的方法是线程不安全的，StringBuffer的方法是线程安全的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>lock锁</p>
<ul>
<li>注意<ul>
<li>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作</li>
<li>Lock中提供了获得锁lock() 和 释放锁unlock()的方法</li>
<li>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</li>
<li>ReentrantLock的构造方法ReentrantLock():创建一个ReentrantLock的实例</li>
</ul>
</li>
</ul>
<h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p>常见方法</p>
<ul>
<li>wait()：当前线程等待，直到被其他线程唤醒</li>
<li>notify()：随机唤醒单个线程</li>
<li>notifyAll()：唤醒所有线程</li>
</ul>
<p>阻塞队列</p>
<ul>
<li>ArrayBlockingQueue：底层是数组，有界的</li>
<li>LinkBlockingQueue：底层是链表，石界但不是真正的干界,最大为int的最七值。</li>
<li>put数据时：放不进去，会等着，也叫做阻塞。</li>
<li>take数据时：取出第一个数据，取不到会等着，也叫做阻塞。</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>原理</p>
<ol>
<li>创建一个池子，池子中是空的</li>
<li>提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可</li>
<li>但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程任务就会排队等待</li>
</ol>
<p>代码实现</p>
<ol>
<li>创建线程池<ul>
<li>方法一（创建一个无上限的线程池）：ExecutorService pool &#x3D; Executors.newCachedThreadPool();</li>
<li>方法二（创建一个有上限的线程池）：ExecutorService pool &#x3D; Executors.newFixedThreadPool(int i);</li>
</ul>
</li>
<li>提交任务<ul>
<li>pool.submit(new MyThread());</li>
</ul>
</li>
<li>销毁线程池<ul>
<li>pool.shutdown();</li>
</ul>
</li>
</ol>
<p>自定义线程池</p>
<ul>
<li>ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);<ul>
<li>参数一：核心线程数量，不能小于0</li>
<li>参数二：最大线程数，不能小于e，最大数量&gt;&#x3D;核心线程数量</li>
<li>参数三：空闲线程最大存活时间，不能小于0</li>
<li>参数四：时间单位，用TimeUnit指定</li>
<li>参数五：任务队列，不能为null</li>
<li>参数六：创建线程工厂，不能为null</li>
<li>参数七：任务的拒绝策略，不能为null</li>
</ul>
</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>介绍</p>
<ul>
<li>ThreadLocal并不是一个Thread，而是Thread的局部变量</li>
<li>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</li>
<li>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</li>
</ul>
<p>常用方法</p>
<ul>
<li>set：设置当前线程的线程局部变量的值</li>
<li>get：返回当前线程所对应的线程局部变量的值</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>Java的线程默认是采用抢占式调度（随机）的。可以通过设置优先级的方式，使线程抢占的概率更高。</li>
<li>堆内存是唯一的，而每个线程都有自己的栈内存</li>
</ul>
<h1 id="Java高级"><a href="#Java高级" class="headerlink" title="Java高级"></a>Java高级</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="认识反射"><a href="#认识反射" class="headerlink" title="认识反射"></a>认识反射</h3><ul>
<li>反射就是∶加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）</li>
<li>简单来说就是：获取类的信息、操作它们。</li>
</ul>
<p>反射的引用场景</p>
<ul>
<li>反射的作用<ul>
<li>可以得到一个类的全部成分然后操作。</li>
<li>可以破坏封装性。</li>
</ul>
</li>
<li>主要用途：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</li>
</ul>
<h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>获取类的三种方式</p>
<ol>
<li>Class c1&#x3D;类名.class</li>
<li>调用Class提供方法：public static Class forName(String package);<ul>
<li>package是全类名（文件在项目中的位置）</li>
</ul>
</li>
<li>object提供的方法：public Class getClass();<ul>
<li>如：Class c3&#x3D;对象.getClass();</li>
</ul>
</li>
</ol>
<ul>
<li>获取类名之后就可以获取类中的成员变量、方法、构造器了</li>
</ul>
<h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>获取构造器的方法</p>
<ol>
<li>Constructor&lt;?&gt;[]  getconstructors()：获取全部由public修饰的构造器</li>
<li>Constructor&lt;?&gt;[]  getDeclaredConstructors：获取全部构造器</li>
<li>Constructor＜T＞ getconstructor(class&lt;?&gt;… parameterTypes)：获取某个由public修饰的构造器</li>
<li>Constructor＜T＞ getDeclaredConstructor(class&lt;?&gt;… parameterTypes)：获取某个构造器</li>
</ol>
<p>获取构造器的作用：依然是初始化对象返回</p>
<ul>
<li>T newInstance(Object… initargs)：调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回，只能调用非私有的构造器</li>
<li>public void setAccessible(boolean flag)：设置为true，表示禁止检查访问控制（暴力反射)，使得私有的构造器也能调用</li>
</ul>
<h3 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h3><p>获取成员变量的方法</p>
<ol>
<li>public Field[] getFields()：获取类的全部成员变量（只能获取public修饰的)</li>
<li>public Field[] getDeclaredFields()：获取类的全部成员变量（只要存在就能拿到)</li>
<li>public Field getField(string name)：获取类的某个成员变量（只能获取public修饰的)</li>
<li>public Field getDeclaredField(string name)：获取类的某个成员变量（只要存在就能拿到)</li>
</ol>
<p>获取成员变量的作用：依然是赋值和取值</p>
<ul>
<li>void set(object obj, object value) ：赋值</li>
<li>object get(object obj)：取值</li>
<li>public void setAccessible(boolean flag)：设置为true，表示禁止检查访问控制（暴力反射)</li>
</ul>
<h3 id="获取类的成员方法"><a href="#获取类的成员方法" class="headerlink" title="获取类的成员方法"></a>获取类的成员方法</h3><p>获取类的成员方法的方式</p>
<ol>
<li>Method[ ] getMethods()：获取类的全部成员方法（只能获取public修饰的)</li>
<li>Method[] getDeclaredMethods()：获取类的全部成员方法(只要存在就能拿到)</li>
<li>Method getMethod(String name,class&lt;?&gt;… parameterTypes)：获取类的某个成员方法(只能获取public修饰的)</li>
<li>Method getDeclaredMethod(String name,class&lt;?&gt;… parameterTypes)：获取类的某个成员方法(只要存在就能拿到)</li>
</ol>
<p>成员方法的作用:依然是执行</p>
<ul>
<li>public object invoke(object obj, object. . . args)：触发某个对象的该方法执行。</li>
<li>public void setAccessible(boolean flag)：设置为true，表示禁止检查访问控制（暴力反射)</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="认识注解"><a href="#认识注解" class="headerlink" title="认识注解"></a>认识注解</h3><p>注解（Annotation）</p>
<ul>
<li>就是Java代码里的特殊标记，比如: @Override、@Test等</li>
<li>作用是让其他程序根据注解信息来决定怎么执行该程序。</li>
<li>注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处。</li>
<li>注解本质是一个接口，Java中所有注解都是继承了Annotation接口的。  </li>
<li>@注解(…):其实就是一个实现类对象，实现了该注解以及Annotation接口。</li>
</ul>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publiuc <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">	<span class="keyword">public</span> 属性类型 属性名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果注解中只有一个value属性，使用注解时，value名称可以不写。</li>
</ul>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>元注解的作用：用来修饰注解的注解。</li>
</ul>
<p>@Target(ElementType.XXX)</p>
<ul>
<li>作用：声明被修饰的注解只能在哪些位置使用</li>
<li>TYPE：类接口</li>
<li>FIELD：成员变量</li>
<li>METHOD：成员方法</li>
<li>PARAMETER：方法参数</li>
<li>CONSTRUCTOR：构造器</li>
<li>LOCAL_VARIABLE：局部变量</li>
</ul>
<p>@Retention(RetentionPolicy.XXX)</p>
<ul>
<li>作用：声明注解的保留周期</li>
<li>SOURCE：只作用在源码阶段，字节码文件中不存在。</li>
<li>CLASS（默认值）：保留到字节码文件阶段，运行阶段不存在。</li>
<li>RUNTIME（开发常用）：一直保留到运行阶段。</li>
</ul>
<h3 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h3><ul>
<li><p>判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来。</p>
</li>
<li><p>要解析谁上面的注解，就应该先拿到谁（通过反射）</p>
</li>
<li><p>AnnotatedElement接口提供了解析注解的方法</p>
<ul>
<li>public Annotation[] getDeclaredAnnotations()：获取当前对象上面的注解。</li>
<li>public T getDeclaredAnnotation(class<T> annotationclass)：获取指定的注解对象</li>
<li>public boolean isAnnotationPresent(class<Annotation> annotationclass)：判断当前对象上是否存在某个注解</li>
</ul>
</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="认识动态代理"><a href="#认识动态代理" class="headerlink" title="认识动态代理"></a>认识动态代理</h3><ul>
<li>对象如果嫌身上干的事太多的话,可以通过代理来转移部分职责。</li>
<li>对象有什么方法想被代理，代理就一定要有对应的方法</li>
</ul>
<h1 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h1><h2 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>网络通信三要素：IP地址、端口、协议</li>
<li>IP地址：<strong>设备</strong>在网络中的地址，是唯一的标识<ul>
<li>常见的IP分类为：IPv4（4字节（32位））和IPv6（16字节（128位））</li>
<li>DNS服务器：也称域名解析器，可将域名解析成IP地址</li>
<li>IP地址的形式：公网地址、和私有地址（局域网使用）</li>
<li>局域网（以太网）：专门为组织机构内部使用，常以192.168.开头，范围是192.168.0.0—192.168.255.255</li>
<li>IP常用命令：ipconfig（查看本机IP地址），ping IP地址（检查网络是否连通）</li>
<li>本机IP地址：127.0.0.1或localhost</li>
</ul>
</li>
<li>端口：<strong>应用程序</strong>在设备中唯一的标识<ul>
<li>端口号:标识正在计算机设备上运行的进程（程序），被规定为一个16位的二进制，范围是0~65535。</li>
<li>周知端口:0~1023，被预先定义的知名应用占用（如:HTTP占用80，FTP占用271</li>
<li>注册端口:1024~49151，分配给用户进程或某些应用程序。(如:Tomcat占用8080，MySQL占用3306)</li>
<li>动态端口:49152到65535。之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配。</li>
<li>注意：一个设备中不能出现两个程序的端口号一样</li>
</ul>
</li>
<li>协议：数据在网络中传输的规则<ul>
<li>OSI参考模型:世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</li>
<li>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议):事实上的国际标准。<ul>
<li>应用层：HTTP、FTP、DNS、SMTP…</li>
<li>传输层：TCP、UDP…</li>
<li>网络层：IP、ICMP…</li>
<li>数据链路层+物理层：物理寻址、比特流…</li>
</ul>
</li>
<li>传输层的两个常见协议<ul>
<li>TCP：传输控制协议（连接，可靠）</li>
<li>UDP：用户数据报协议（不连接，不可靠）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><ul>
<li>此类表示Internet协议（IP）地址</li>
<li>常用API<ul>
<li>InetAddress getLocalHost()：返回本主机的地址对象</li>
<li>InetAddress getByName(String host):得到指定主机的IP地址对象，参数是域名或者IP地址</li>
<li>String getHostName():获取此IP地址的主机名（域名）</li>
<li>String getHostAddress():返回IP地址字符串</li>
<li>boolean isReachable(int timeout):在指定毫秒内连通该IP地址对应的主机，连通放回true</li>
</ul>
</li>
</ul>
<h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><ul>
<li><p>DatagramSocket:UDP的发送端和接收段对象</p>
<ul>
<li>void send(DatagramPacket dp):发送数据包</li>
<li>void receive(DatagramPacket dp):接收数据包</li>
</ul>
</li>
<li><p>DatagramPacket:数据包对象</p>
<ul>
<li>发送端对象：DatagramPacket(byte buf[], int length,InetAddress address, int port)</li>
<li>接收段对象：DatagramPacket(byte buf[], int length)</li>
</ul>
</li>
<li><p>列子</p>
<ul>
<li>发送端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户发送端========================&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建发送端对象（发送端自带默认端口号）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2创建一个数据包对象封装数据</span></span><br><span class="line">        <span class="type">byte</span>[] sData = <span class="string">&quot;你好，我是JY&quot;</span>.getBytes();<span class="comment">//要发送的数据</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数一：要发送的数据</span></span><br><span class="line"><span class="comment">        参数二：发送数据的大小</span></span><br><span class="line"><span class="comment">        参数三：接收端的IP地址</span></span><br><span class="line"><span class="comment">        参数四：接收端的端口</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(sData, sData.length, InetAddress.getLocalHost(),<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.发送数据出去</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接收端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serverg1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务接受端=======================&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建接收端对象，注册端口号</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个数据包对象接收数据</span></span><br><span class="line">        <span class="type">byte</span> [] rData= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(rData,rData.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.等待接收数据</span></span><br><span class="line">        server.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取接收数据的大小，并输出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dataLenth</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">        <span class="type">String</span> <span class="variable">strData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(rData,<span class="number">0</span>,dataLenth);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到了:&quot;</span>+strData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h2><ul>
<li>概念：JDBC就是使用Java语言操作关系型数据库的一套API，全称：( Java DataBase Connectivity ) Java数据库连接。</li>
<li>本质：官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。</li>
</ul>
<h2 id="快速入门步骤"><a href="#快速入门步骤" class="headerlink" title="快速入门步骤"></a>快速入门步骤</h2><ol start="0">
<li><p>创建工程，导入驱动jar包</p>
</li>
<li><p>注册驱动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//在mysql 5之后的驱动jar包可以不做这一步</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义sql语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;要执行的sql语句&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取执行sql对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement();</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeQuery(<span class="keyword">sql</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理返回结果</p>
</li>
<li><p>释放资源</p>
</li>
</ol>
<h2 id="JDBC-API详解"><a href="#JDBC-API详解" class="headerlink" title="JDBC API详解"></a>JDBC API详解</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><ul>
<li>作用：注册驱动、获取数据库连接</li>
</ul>
<ol>
<li><p>注册驱动：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<span class="operator">/</span><span class="operator">/</span>在mysql <span class="number">5</span>之后的驱动jar包可以不做这一步</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取连接：</p>
<ul>
<li><p>Connection getConnection(Strng url,String user,String password)</p>
</li>
<li><p>参数url语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2…</p>
</li>
<li><p>可配置useSSL&#x3D;false参数，禁用安全连接方式，解决警告提示。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul>
<li>作用：获取执行sql的对象、管理事务</li>
</ul>
<ol>
<li>获取执行sql的对象<ul>
<li>普通执行sql对象：Statement createStatement()</li>
<li>预编译SQL的执行SQL对象:防止SQL注入：PrepareStatement  prepareStatement(sql)</li>
<li>执行存储过程的对象：CallableStatement prepareCall(sql)</li>
</ul>
</li>
<li>管理事务<ol>
<li>开启事务：setAutoCommit(boolean autoCommit)：true为自动提交事务;false为手动提交事务</li>
<li>提交事务：commit()</li>
<li>回滚事务：rollback()</li>
</ol>
</li>
</ol>
<h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><ul>
<li><p>作用：执行sql语句</p>
</li>
<li><p>执行DML、DDL语句：int executeUpdate(sql)</p>
<ul>
<li>DML语句返回值：DML语句影响的行数（DML）</li>
<li>DDL语句返回值：DDL语句执行后，执行成功也可能返回0</li>
</ul>
</li>
<li><p>执行DQL语句：ResultSet executeQuery(sql)</p>
<ul>
<li>返回值：ResultSet结果集对象</li>
</ul>
</li>
</ul>
<h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><ul>
<li>作用：封装DQL查询语句的结果</li>
<li>boolean next()<ul>
<li>常跟着循环一起使用</li>
<li>改方法会将光标从当前位置向下移动一行，并判断当前行是否为有效行</li>
</ul>
</li>
<li>xxx getXxx(参数)<ul>
<li>xxx指的是数据类型，根据需求写。</li>
<li>如：int getInt(参数)和String getString(参数)</li>
</ul>
</li>
</ul>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><ul>
<li>作用：预编译SQL并执行SQL语句</li>
</ul>
<ol>
<li><p>获取PreparedStatement对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrepareStatement</span> <span class="variable">prst</span> <span class="operator">=</span> con.prepareStatemnt(sql); <span class="comment">//sql语句中的参数值用？代替</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置参数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prst.setXxx(参数<span class="number">1</span>，参数<span class="number">2</span>);</span><br><span class="line"><span class="comment">//Xxx指的是数据类型，参数1是sql语句中?的位置编号，参数2是要设给？的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prst.executeUpdate()或executeQuery();</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>介绍</p>
<ul>
<li>数据结构是计算机底层存储、组织数据的方式。</li>
<li>是指数据相互之间是以什么方式排列在一起的。</li>
<li>数据结构是为了更加方便的管理和使用数据，需要结合具体的业务场景来进行选择。</li>
<li>一般情况下，精心选择的数据结构可以带来更高的运行或者存储效率。</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731138.png" alt="image-20240312204540277"></p>
<p>特点</p>
<ul>
<li>先进后出，后进先出</li>
<li>数据进入栈模型的过程称为：压&#x2F;进栈</li>
<li>数据离开栈模型的过程称为：弹&#x2F;出栈</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732817.png" alt="image-20240312204620758"></p>
<p>特点</p>
<ul>
<li>先进先出，后进后出</li>
<li>数据从后端进入队列模型的过程称为：入队列</li>
<li>数据从前端离开队列模型的过程称为：出队列</li>
</ul>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>特点</p>
<ul>
<li>查询快：查询数据通过地址值和索引定位，查询任意数据耗时相同。(元素在内存中是<em><strong>连续</strong></em>存储的)</li>
<li>删除慢：要将原始数据删除，同时后面每个数据前移。</li>
<li>添加慢：添加位置后的每个数据后移，再添加元素。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>单向链表</p>
<p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732721.png" alt="image-20240312211111795"></p>
<p>双向链表</p>
<p><img src="https://gitee.com/lujiaye/picture-bed/raw/master/img/202403122111336.png" alt="image-20240312211143209"></p>
<p>特点</p>
<ul>
<li>链表中的结点是独立的对象，在内存中是<em><strong>不连续</strong></em>的，每个结点包含数据值和下一个结点的地址。</li>
<li>链表<em><strong>查询慢</strong></em>，无论查询哪个数据都要从头开始找。</li>
<li>链表<em><strong>增删相对快</strong></em></li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><ul>
<li>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</li>
<li><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</li>
<li><strong>回溯法解决的问题都可以抽象为树形结构</strong>，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</li>
</ul>
<p>回溯三部曲</p>
<ol>
<li>回溯函数模板返回值以及参数</li>
<li>回溯函数终止条件</li>
<li>回溯搜索的遍历过程</li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>组合问题</li>
<li>排列问题</li>
<li>切割问题</li>
<li>子集问题</li>
<li>棋盘问题（N皇后、解数独）</li>
</ul>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732546.png" alt="image-20240405221811922"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入: [1,2,3]</span></span><br><span class="line"><span class="comment"> * 输出: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">paiLie1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; listpath = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> used[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrs = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">boolean</span>[arrs.length];</span><br><span class="line">        backTracking(arrs);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] arrs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arrs.length==listpath.size())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(listpath));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">            listpath.add(arrs[i]);</span><br><span class="line">            backTracking(arrs);</span><br><span class="line">            listpath.remove(listpath.size()-<span class="number">1</span>);</span><br><span class="line">            used[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732470.png" alt="image-20240405223050408"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">zuHe1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; result= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; path= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>startIndex;i&lt;=n;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h3><ul>
<li>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</li>
<li>贪心没有套路，说白了就是常识性推导加上举反例。</li>
</ul>
<p>贪心四部曲</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="理论基础-2"><a href="#理论基础-2" class="headerlink" title="理论基础"></a>理论基础</h3><ul>
<li>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</li>
<li>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的</li>
</ul>
<p>动态规划五部曲</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>背包问题</li>
<li>路径问题</li>
<li>爬楼梯问题</li>
<li>股票问题</li>
<li>子序列问题</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="重复子串"><a href="#重复子串" class="headerlink" title="重复子串"></a>重复子串</h3><p>问题：判断一个字符串，能否由它的一个子串重复多次构成，如：</p>
<ul>
<li>输入”abab“，输出true</li>
<li>输入”aba“，输出false</li>
</ul>
<p>解法一（移动匹配法）</p>
<ul>
<li>将原字符串*2，再去头去尾得到一个新的字符串，如果新字符串还包含原字符串则为true，否则为false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bu.readLine();</span><br><span class="line">        String str2= str+str;</span><br><span class="line">        str2=str2.substring(<span class="number">1</span>,str2.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str2.contains(str))&#123;</span><br><span class="line">            System.out.println(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二（KMP算法）</p>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>字符串替换可以用正则表达式来做如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=str.replaceAll(&quot;a&#123;10,&#125;&quot;, &quot;b&quot;); //用b来替换str中全部超过9个连续的a</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;jybzzz&quot;</span>;</span><br><span class="line"><span class="comment">//1.反转字符串:用StringBuilder类中的reverse()</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str1).reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1字符串的比较:compareTo(str)</span></span><br><span class="line"><span class="comment">//先按照字典次序大小比较，如果出现不等的字符，直接返回这两个字符的大小差值。</span></span><br><span class="line">String str3=<span class="string">&quot;help&quot;</span>;</span><br><span class="line">String str4=<span class="string">&quot;hell&quot;</span>;</span><br><span class="line">System.out.println(str3.compareTo(str4));<span class="comment">//打印4，p与l的字符大小差值</span></span><br><span class="line"><span class="comment">//如果前k个字符都相等，只是长度不同，那么返回两个字符串长度差值。</span></span><br><span class="line">String str5=<span class="string">&quot;help me&quot;</span>;</span><br><span class="line">System.out.println(str3.compareTo(str5));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.字符串的查找</span></span><br><span class="line"><span class="comment">//charAt(int index):此方法返回index位置上的字符</span></span><br><span class="line">System.out.println(str1.charAt(<span class="number">3</span>));</span><br><span class="line"><span class="comment">//indexOf(String str):此方法为返回str第一次出现的位置</span></span><br><span class="line">System.out.println(str1.indexOf(<span class="string">&quot;zzz&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.字符串的转换</span></span><br><span class="line"><span class="comment">//转数字:Integer.parseInt(str)</span></span><br><span class="line">String str6=<span class="string">&quot;12345&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转数字:&quot;</span>+Integer.parseInt(str6));</span><br><span class="line"><span class="comment">//转数组：toCharArray()</span></span><br><span class="line"><span class="type">char</span>[] chars = str1.toCharArray();</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转数组:&quot;</span>+Arrays.toString(chars));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.字符串的替换</span></span><br><span class="line">String str7=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//replaceAll(str1,str2):将字符串中的全部str1替换成str2</span></span><br><span class="line">System.out.println(str7.replaceAll(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>));</span><br><span class="line"><span class="comment">//replaceAll(str1,str2):将字符串中的第一个str1替换成str2</span></span><br><span class="line">System.out.println(str7.replaceFirst(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.字符串拆分:split(str)</span></span><br><span class="line">String str8=<span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">String[] os = str8.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(os));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.字符串截取:substring(int start,int end)   注：左闭右开</span></span><br><span class="line">System.out.println(str1.substring(<span class="number">1</span>,str1.length()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.大小写转换</span></span><br><span class="line">String str9=<span class="string">&quot;JyBzZz&quot;</span>;</span><br><span class="line"><span class="comment">//将字符串全部变为小写:toLowerCase()</span></span><br><span class="line">System.out.println(str9.toLowerCase());</span><br><span class="line"><span class="comment">//将字符串全部变为大写:toUpperCase()</span></span><br><span class="line">System.out.println(str9.toUpperCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.字符串去空格</span></span><br><span class="line"><span class="comment">//去掉字符串中的左右空格,保留中间空格:trim()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str10</span> <span class="operator">=</span> <span class="string">&quot;    j y b z z z    &quot;</span>;</span><br><span class="line">System.out.println(str10.trim());</span><br><span class="line"><span class="comment">//去掉全部空格：replaceAll(&quot; &quot;,&quot;&quot;)</span></span><br><span class="line">System.out.println(str10.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>


<h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>字符串转数字<ul>
<li>Interger.parseInt(str)</li>
</ul>
</li>
<li>数组转List集合<ul>
<li>Arrays.<strong>asList</strong>(arr)</li>
</ul>
</li>
<li>集合转数组<ul>
<li>arr.<strong>toArray</strong>()</li>
</ul>
</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li><p>数组</p>
<ul>
<li>升序：Arrays.sort(array);</li>
</ul>
</li>
<li><p>集合</p>
<ul>
<li>升序：Collections.sort(list);</li>
<li>降序（先升序再reverse)：Collections.reverse(list);</li>
</ul>
</li>
<li><p>自定义对象按某个属性排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">22</span>));</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>));</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">25</span>));</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;David&quot;</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">Collections.sort(studentList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.getAge()-s2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组集合"><a href="#数组集合" class="headerlink" title="数组集合"></a>数组集合</h2><p>数组</p>
<ul>
<li><p>数组截取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(原始数组,截取的开始位置,截取后的新数组,<span class="number">0</span>,截取的长度);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(数组名).sum()</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组求最大值最小值平均值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最大值：Arrays.stream(arr).max().getAsInt()</span><br><span class="line">最小值：Arrays.stream(arr).min().getAsInt()</span><br><span class="line">平均值：Arrays.stream(arr).average().getAsDouble()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> * 取整运算</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//        1、四舍五入round</span></span><br><span class="line">        <span class="type">int</span> num1=Math.round(<span class="number">3.4f</span>);</span><br><span class="line">        System.out.println(num1);</span><br><span class="line"><span class="comment">//		  2.String.format()		 </span></span><br><span class="line">		String.format(<span class="string">&quot;%.要保留的小数位数f&quot;</span>,num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2.向上取整ceil</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Math.ceil(<span class="number">3.5f</span>);</span><br><span class="line">        System.out.println((<span class="type">int</span>)num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        3.向下取整floor</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num3</span> <span class="operator">=</span> Math.floor(<span class="number">3.5</span>);</span><br><span class="line">        System.out.println((<span class="type">int</span>)num3);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指数运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//        1.返回以a为底数，以b为指数的幂值pow</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num4</span> <span class="operator">=</span> Math.pow(<span class="number">16</span>,<span class="number">0.5</span>);</span><br><span class="line">        System.out.println(num4);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        1.返回大于等于 0.0、小于 1.0 的 double 类型随机数random</span></span><br><span class="line">        <span class="type">double</span> numran=Math.random();</span><br><span class="line">        System.out.println(numran);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3.5</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%.2f&quot;</span>,num);</span><br></pre></td></tr></table></figure>

<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><pre><code> BigDecimal类是Java中提供的一个用于精确计算和表示任意精度的十进制数的类
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal b)</span>加法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal b)</span>减法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal b)</span>乘法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal b)</span>除法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(另一个BigDecimal对象，精确几位，舍入模式)</span>除法</span><br></pre></td></tr></table></figure>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li><p>equals和&#x3D;&#x3D;</p>
<ul>
<li>“&#x3D;&#x3D;”是运算符，如果是基本数据类型，则比较存储的值；如果是引用数据类型，则比较所指向对象的地址值。</li>
<li>quals是Object的方法，默认比较的是对象的地址值。可以通过重写从而比较的对象的值。如String</li>
</ul>
</li>
<li><p><code>classpath</code> 和 <code>path</code> 环境变量的查看与配置的方式完全相同。</p>
</li>
<li><p>synchronized 关键字有同步代码块和同步方法2 种</p>
</li>
<li><p>默认的 <code>equals()</code> 方法在比较两个对象时，使用的是引用比较，而String中的equals方法使用的是值比较。</p>
</li>
<li><p>对于基本数据类型&#x3D;&#x3D;是值比较，对于引用数据类型&#x3D;&#x3D;是引用比较</p>
</li>
<li><p>对于String s1&#x3D;”abc”，”abc“是放在方法区中的字符串常量池里面，它是可以共享和重用的。而对于String s1&#x3D;new String(“abc”)，”abc“是放在堆内存中的。</p>
</li>
<li><p>StringBuilder的equals用的是默认的比较方式。</p>
</li>
<li><p>StringBuilde是非线程安全的，StringBuffer是线程安全的</p>
</li>
<li><p>Arraylist是非线程安全的，Vector是线程安全的</p>
</li>
<li><p>HashMap是非线程安全的，HashTables是线程安全的</p>
</li>
<li><p>堆内存是唯一的，而每个线程都有自己的栈内存</p>
</li>
<li><p>File 对象既可以表示文件，也可以表示目录，它可以查出与文件相关的信息，<strong>不包括文件内容</strong>。</p>
</li>
<li><p>super(参数)：调用父类中的某一个<strong>构造器</strong></p>
</li>
<li><p>局部变量在使用前必须被初始化，成员变量不用。</p>
</li>
<li><p>switch</p>
<ul>
<li>后面的小括号只能是基本数据类型和String、enum</li>
<li>匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止</li>
<li>case后面的数值不可以重复</li>
</ul>
</li>
<li><p>Java中的自动装箱是指：自动将基本数据类型转换为对应的包装类对象。</p>
</li>
<li><p>静态方法</p>
<ul>
<li><strong>静态方法只能访问静态成员和方法，不可以“直接”访问实例成员和方法</strong></li>
<li>静态方法属于类而不属于实例，是不能被实例化的方法。</li>
</ul>
</li>
<li><p>断言是一种用于验证程序中的条件是否为真的机制，通常用于调试和测试阶段。</p>
</li>
<li><p>线程是一种用于<strong>并发</strong>执行的单元，可以同时运行多个线程实现多任务。</p>
</li>
<li><p>布尔类型不能被强制类型转换为其他数据类型</p>
</li>
</ul>
<h1 id="Idea快捷键"><a href="#Idea快捷键" class="headerlink" title="Idea快捷键"></a>Idea快捷键</h1><ul>
<li>alt+insert：构造器、GetSet方法、ToString、equals() and hashCode()快速生成</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://blog.jybzzz.cc">Jybzzz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://blog.jybzzz.cc/2024/04/29/Java%E7%AC%94%E8%AE%B0/">http://blog.jybzzz.cc/2024/04/29/Java%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.jybzzz.cc" target="_blank">JyBlog🏀🐓</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/assets/%E8%B7%AF%E9%A3%9E4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/04/29/HtmlCssJs/" title="HtmlCssJs"><img class="cover" src="/assets/%E8%B7%AF%E9%A3%9E7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HtmlCssJs</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/%E8%B7%AF%E9%A3%9E.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jybzzz</div><div class="author-info__description">我一路向北</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">1.2.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.3.</span> <span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">变量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.8.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.9.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E9%94%99%E8%AF%AF"><span class="toc-number">1.11.</span> <span class="toc-text">异常与错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.11.1.</span> <span class="toc-text">异常的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.11.2.</span> <span class="toc-text">异常的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.11.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">程序流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if"><span class="toc-number">2.1.</span> <span class="toc-text">if</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">2.1.1.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.1.2.</span> <span class="toc-text">三元运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for"><span class="toc-number">2.2.</span> <span class="toc-text">for</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while"><span class="toc-number">2.3.</span> <span class="toc-text">while</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">方法的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">方法重载（Overload）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">方法重写（Override）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">构造方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">4.1.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">封装的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">封装的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.1.3.</span> <span class="toc-text">封装的步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">继承的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">继承的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text">继承的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends"><span class="toc-number">4.2.4.</span> <span class="toc-text">extends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#implements"><span class="toc-number">4.2.5.</span> <span class="toc-text">implements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">4.2.6.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">4.2.7.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%92%8Csuper%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.8.</span> <span class="toc-text">this和super的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">4.3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">多态的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">多态的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.3.3.</span> <span class="toc-text">多态存在的三个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.4.</span> <span class="toc-text">多态的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E4%B8%AD%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">4.3.5.</span> <span class="toc-text">多态中成员访问特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static"><span class="toc-number">4.4.</span> <span class="toc-text">Static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">4.5.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">抽象类（abstract）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">接口（interface）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.1.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.2.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.3.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.4.</span> <span class="toc-text">静态内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE-enum"><span class="toc-number">4.9.</span> <span class="toc-text">枚举(enum)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88"><span class="toc-number">5.1.</span> <span class="toc-text">Collection集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E7%89%B9%E7%82%B9"><span class="toc-number">5.1.1.</span> <span class="toc-text">Collection特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E9%80%9A%E7%94%A8API"><span class="toc-number">5.1.2.</span> <span class="toc-text">Collection通用API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">5.1.3.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinekdList"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">LinekdList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">5.1.4.</span> <span class="toc-text">Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">5.2.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">Map特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%80%9A%E7%94%A8API"><span class="toc-number">5.2.2.</span> <span class="toc-text">Map通用API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">5.2.3.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">5.2.4.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">5.2.5.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection"><span class="toc-number">5.3.1.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">增强for遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">Lambda表达式遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-List%E7%89%B9%E6%9C%89"><span class="toc-number">5.3.1.4.</span> <span class="toc-text">列表迭代器(List特有)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">5.3.2.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E6%89%BE%E5%80%BC"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">键找值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">键值对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">Lambda表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">5.4.</span> <span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="toc-number">5.4.1.</span> <span class="toc-text">不可变集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.4.2.</span> <span class="toc-text">Stream的使用步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">6.1.1.</span> <span class="toc-text">字符流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">线程的创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">Thread常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.</span> <span class="toc-text">线程的生命周期和安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">7.5.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-number">7.6.</span> <span class="toc-text">等待唤醒机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.7.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">7.8.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">7.9.</span> <span class="toc-text">基础知识</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%AB%98%E7%BA%A7"><span class="toc-number">8.</span> <span class="toc-text">Java高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">8.1.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%8F%8D%E5%B0%84"><span class="toc-number">8.1.1.</span> <span class="toc-text">认识反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB"><span class="toc-number">8.1.2.</span> <span class="toc-text">获取类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.1.3.</span> <span class="toc-text">获取构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">8.1.4.</span> <span class="toc-text">获取类的成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.5.</span> <span class="toc-text">获取类的成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.1.</span> <span class="toc-text">认识注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.2.</span> <span class="toc-text">自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.2.3.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">8.2.4.</span> <span class="toc-text">注解的解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">8.3.1.</span> <span class="toc-text">认识动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Net"><span class="toc-number">9.</span> <span class="toc-text">Net</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1"><span class="toc-number">9.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress"><span class="toc-number">9.2.</span> <span class="toc-text">InetAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="toc-number">9.3.</span> <span class="toc-text">UDP通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1"><span class="toc-number">9.4.</span> <span class="toc-text">TCP通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDBC"><span class="toc-number">10.</span> <span class="toc-text">JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC%E7%AE%80%E4%BB%8B"><span class="toc-number">10.1.</span> <span class="toc-text">JDBC简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.2.</span> <span class="toc-text">快速入门步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC-API%E8%AF%A6%E8%A7%A3"><span class="toc-number">10.3.</span> <span class="toc-text">JDBC API详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DriverManager"><span class="toc-number">10.3.1.</span> <span class="toc-text">DriverManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Connection"><span class="toc-number">10.3.2.</span> <span class="toc-text">Connection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Statement"><span class="toc-number">10.3.3.</span> <span class="toc-text">Statement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResultSet"><span class="toc-number">10.3.4.</span> <span class="toc-text">ResultSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PreparedStatement"><span class="toc-number">10.3.5.</span> <span class="toc-text">PreparedStatement</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">11.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">11.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-number">11.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">11.4.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.5.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">11.6.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.7.</span> <span class="toc-text">平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AF%87"><span class="toc-number">12.</span> <span class="toc-text">算法篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">12.1.</span> <span class="toc-text">回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">12.1.1.</span> <span class="toc-text">理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.2.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">12.1.3.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.4.</span> <span class="toc-text">排列问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.5.</span> <span class="toc-text">组合问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">12.2.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-1"><span class="toc-number">12.2.1.</span> <span class="toc-text">理论基础</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">12.3.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-2"><span class="toc-number">12.3.1.</span> <span class="toc-text">理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-1"><span class="toc-number">12.3.2.</span> <span class="toc-text">常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">12.4.1.</span> <span class="toc-text">重复子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="toc-number">12.4.2.</span> <span class="toc-text">字符串替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">12.5.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">12.6.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88"><span class="toc-number">12.7.</span> <span class="toc-text">数组集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">12.8.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal"><span class="toc-number">12.9.</span> <span class="toc-text">BigDecimal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Idea%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">14.</span> <span class="toc-text">Idea快捷键</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/19/final/" title="商务智能课设"><img src="/assets/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="商务智能课设"/></a><div class="content"><a class="title" href="/2024/06/19/final/" title="商务智能课设">商务智能课设</a><time datetime="2024-06-19T00:45:52.488Z" title="发表于 2024-06-19 08:45:52">2024-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/30/Spring/" title="Spring"><img src="/assets/%E5%91%A8%E6%9D%B0%E4%BC%A64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2024/04/30/Spring/" title="Spring">Spring</a><time datetime="2024-04-30T01:47:46.623Z" title="发表于 2024-04-30 09:47:46">2024-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/30/Redis/" title="Redis"><img src="/assets/%E5%91%A8%E6%9D%B0%E4%BC%A61.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2024/04/30/Redis/" title="Redis">Redis</a><time datetime="2024-04-30T01:46:07.959Z" title="发表于 2024-04-30 09:46:07">2024-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/30/MybatisPlus/" title="MybatisPlus"><img src="/assets/%E5%91%A8%E6%9D%B0%E4%BC%A62.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MybatisPlus"/></a><div class="content"><a class="title" href="/2024/04/30/MybatisPlus/" title="MybatisPlus">MybatisPlus</a><time datetime="2024-04-30T01:44:59.960Z" title="发表于 2024-04-30 09:44:59">2024-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/30/Mybatis/" title="Mybatis"><img src="/assets/%E5%91%A8%E6%9D%B0%E4%BC%A63.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis"/></a><div class="content"><a class="title" href="/2024/04/30/Mybatis/" title="Mybatis">Mybatis</a><time datetime="2024-04-30T01:43:07.397Z" title="发表于 2024-04-30 09:43:07">2024-04-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Jybzzz</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://blog.jybzzz.cc/categories/编程语言/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 编程语言 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://blog.jybzzz.cc/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 面试 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://blog.jybzzz.cc/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 前端 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://blog.jybzzz.cc/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 数据库 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://blog.jybzzz.cc/categories/SpringMVC/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 SpringMVC (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://blog.jybzzz.cc/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/06/19/final/" alt=""><img width="48" height="48" src="/assets/商务智能.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-19</span><a class="blog-slider__title" href="2024/06/19/final/" alt="">商务智能课设</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/06/19/final/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/29/Java笔记/" alt=""><img width="48" height="48" src="/assets/路飞4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-29</span><a class="blog-slider__title" href="2024/04/29/Java笔记/" alt="">Java</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/29/Java笔记/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/29/Mysql/" alt=""><img width="48" height="48" src="/assets/路飞5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-29</span><a class="blog-slider__title" href="2024/04/29/Mysql/" alt="">Mysql</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/29/Mysql/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/29/HtmlCssJs/" alt=""><img width="48" height="48" src="/assets/路飞7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-29</span><a class="blog-slider__title" href="2024/04/29/HtmlCssJs/" alt="">HtmlCssJs</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/29/HtmlCssJs/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/30/Spring/" alt=""><img width="48" height="48" src="/assets/周杰伦4.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-30</span><a class="blog-slider__title" href="2024/04/30/Spring/" alt="">Spring</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/30/Spring/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/30/Mybatis/" alt=""><img width="48" height="48" src="/assets/周杰伦3.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-30</span><a class="blog-slider__title" href="2024/04/30/Mybatis/" alt="">Mybatis</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/30/Mybatis/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/30/MybatisPlus/" alt=""><img width="48" height="48" src="/assets/周杰伦2.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-30</span><a class="blog-slider__title" href="2024/04/30/MybatisPlus/" alt="">MybatisPlus</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/30/MybatisPlus/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/30/Redis/" alt=""><img width="48" height="48" src="/assets/周杰伦1.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-30</span><a class="blog-slider__title" href="2024/04/30/Redis/" alt="">Redis</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/30/Redis/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/29/Vue/" alt=""><img width="48" height="48" src="/assets/周杰伦9.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-29</span><a class="blog-slider__title" href="2024/04/29/Vue/" alt="">Vue-Elementui-Nginx</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/29/Vue/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/04/29/面试/" alt=""><img width="48" height="48" src="/assets/周杰伦8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-04-29</span><a class="blog-slider__title" href="2024/04/29/面试/" alt="">常见面试题</a><div class="blog-slider__text">故事的小黄花，从出生那年就飘着~</div><a class="blog-slider__button" href="2024/04/29/面试/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题使用Butterfly" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>