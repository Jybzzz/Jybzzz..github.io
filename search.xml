<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>商务智能课设</title>
      <link href="/2024/06/19/final/"/>
      <url>/2024/06/19/final/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《商务智能应用方法》期末课程设计</p><p>基于历史数据的天气预测模</p><p>组员：2115090116 卢家业      2115090118 覃庆烽</p></blockquote><h1 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h1><h1 id="二、研究背景与意义"><a href="#二、研究背景与意义" class="headerlink" title="二、研究背景与意义"></a>二、研究背景与意义</h1><h1 id="三、数据来源"><a href="#三、数据来源" class="headerlink" title="三、数据来源"></a>三、数据来源</h1><h1 id="四、数据存储与预处理"><a href="#四、数据存储与预处理" class="headerlink" title="四、数据存储与预处理"></a>四、数据存储与预处理</h1><h1 id="五、建立数据挖掘模型"><a href="#五、建立数据挖掘模型" class="headerlink" title="五、建立数据挖掘模型"></a>五、建立数据挖掘模型</h1><h1 id="六、可视化展示与分析"><a href="#六、可视化展示与分析" class="headerlink" title="六、可视化展示与分析"></a>六、可视化展示与分析</h1><h2 id="课题一"><a href="#课题一" class="headerlink" title="课题一"></a>课题一</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Pie</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Timeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件并准备数据</span></span><br><span class="line">city_names = [<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;长春&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;南宁&quot;</span>]</span><br><span class="line">file_paths = [<span class="string">&quot;GZ2.csv&quot;</span>, <span class="string">&quot;CC2.csv&quot;</span>, <span class="string">&quot;BJ2.csv&quot;</span>, <span class="string">&quot;NN2.csv&quot;</span>]</span><br><span class="line"></span><br><span class="line">timelinedata = []</span><br><span class="line"><span class="keyword">for</span> city, file_path <span class="keyword">in</span> <span class="built_in">zip</span>(city_names, file_paths):</span><br><span class="line">    weather_data = pd.read_csv(file_path, encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line">    wind_counts = weather_data[<span class="string">&#x27;风力&#x27;</span>].value_counts()</span><br><span class="line">    data = [(wind, count) <span class="keyword">for</span> wind, count <span class="keyword">in</span> wind_counts.items()]</span><br><span class="line">    timelinedata.append((city, data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建时间轮播图</span></span><br><span class="line">timeline = Timeline()</span><br><span class="line"><span class="keyword">for</span> city, data <span class="keyword">in</span> timelinedata:</span><br><span class="line">    pie = (</span><br><span class="line">        Pie()</span><br><span class="line">        .add(</span><br><span class="line">            <span class="string">&quot;&quot;</span>,</span><br><span class="line">            data,</span><br><span class="line">            radius=[<span class="string">&quot;30%&quot;</span>, <span class="string">&quot;75%&quot;</span>],</span><br><span class="line">            center=[<span class="string">&quot;50%&quot;</span>, <span class="string">&quot;50%&quot;</span>],</span><br><span class="line">            </span><br><span class="line">        )</span><br><span class="line">        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">f&quot;<span class="subst">&#123;city&#125;</span>风力等级分布&quot;</span> , pos_left=<span class="string">&quot;0%&quot;</span>, pos_top=<span class="string">&quot;20%&quot;</span>))</span><br><span class="line"><span class="comment">#         .set_series_opts(label_opts=opts.LabelOpts(formatter=&quot;&#123;b&#125;: &#123;d&#125;%&quot;))</span></span><br><span class="line">    )</span><br><span class="line">    timeline.add(pie, city)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 渲染为HTML文件</span></span><br><span class="line">timeline.render(<span class="string">&quot;各个城市风力等级占比.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;风力等级时间轮播图已生成并保存为 &#x27;wind_force_timeline_chart.html&#x27;&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>链接：</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202406190841562.png" alt="image-20240619084108475"></p>]]></content>
      
      
      <categories>
          
          <category> 课设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 商务智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2024/04/30/Spring/"/>
      <url>/2024/04/30/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h2><ul><li>内聚:软件中各个功能模块内部的功能联系。</li><li>耦合:衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</li><li>软件设计原则:高内聚低耦合。</li></ul><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>controller：表现层，接收前端发送的请求，对请求进行处理，并响应数据。</li><li>service：业务逻辑层，处理具体的业务逻辑。</li><li>dao：数据访问层(Data Access Object)(持久层)，负责数据访问操作，包括数据的增、删、改、查。</li></ul><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><ul><li>控制反转:Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（IOC容器)，这种思想称为控制反转(使用对象时，由主动new产生对象转换为由外部提供对象)。</li><li>加上@Component注解，即可将当前类交给IOC容器管理，成为IOC容器中的bean</li><li>@Componnent的衍生注解，因为@Component往往不会用在三层架构上。<ul><li>@Controller：标注在控制器类（Controller层）上</li><li>@Service：：标注在业务类（Service层）上</li><li>@Repository：标注在数据访问类上（Dao层）上</li></ul></li><li>注意<ul><li>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器（Controller层）bean只能用@Controller。因为Controller层的@RestController&#x3D;@Controller+@ResponseBody。</li></ul></li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul><li><p>依赖注入:Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p><ul><li>加上@Autowired注解，运行时，IOC容器会提供该类型的bean对象，并赋值给该变量–依赖注入</li></ul></li><li><p>@Autowired注解，默认是按照类型进行，如果存在多个相同类型的bean，将会报错误，解决方案</p><ul><li>@Primary注解：在对应的bean类上加上，即可指定优先级更高</li><li>@Qualifier注解：通过@Autowired注解和@Qualifier注解（“指定bean名”）指定注入哪个bean</li><li>@Resource注解 ：不用@Autowired注解而是改成@Resource注解（name&#x3D;“指定bean名”）</li></ul></li></ul><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><ul><li>Bean对象:IOC容器中创建、管理的对象，称之为bean。</li><li>Bean组件扫描<ul><li>默认扫描的范围是启动类所在包及其子包。</li></ul></li><li>声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。</li><li>主动获取bean,通过AplicationContext IOC容器对象中的方法<ul><li>根据名称获取：Object getBean(String name)</li><li>根据类型获取：＜T＞ T getBean(Class＜T＞ requiredType)</li><li>根据名称和类型获取：＜T＞ T getBean(String name  ,  Class＜T＞ requiredType)</li></ul></li></ul><p>bean作用域</p><ul><li><p>可以通过@Scope(“作用域”)来配置作用域</p><ul><li><p>singletion：容器内同名称的bean只有一个实例（单例)（默认)</p></li><li><p>prototype：每次使用该bean时会创建新的实例（非单例)</p></li><li><p>request：每个请求范围内会创建新的实例(web环境中，了解)</p></li><li><p>session：每个会话范围内会创建新的实例（web环境中，了解)</p></li><li><p>application：每个应用范围内会创建新的实例( web环境中，了解)</p></li></ul></li><li><p>注意</p><ul><li>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时)。</li><li>prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</li><li>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。</li></ul></li></ul><p>第三方bean</p><ul><li>如果要管理的bean对象来自于第三方(不是自定义的)，是无法用@Component及衍生注解声明bean的，就需要用到@Bean注解。<ul><li>@Bean是加在方法上的，不是类名上</li></ul></li><li>若要管理的第三方bean对象，建议对这些bean进行集中分类配置，可以通过@Configuration注解声明一个配置类。</li><li>通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。</li><li>如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="AOP基本概念"><a href="#AOP基本概念" class="headerlink" title="AOP基本概念"></a>AOP基本概念</h3><p>什么是AOP</p><ul><li>AOP就是面向切面编程，其实就是面向特定方法编程。</li></ul><p>作用</p><ul><li>利用AOP可以对业务逻辑的各个部分进行隔离，从而是的业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</li><li>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</li></ul><p>使用场景</p><ul><li>记录操作日志、权限控制、事务管理等</li></ul><p>实现原理</p><ul><li>动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。</li></ul><h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3><ul><li>切入点：PointCut，被AOP控制的匹配连接点的条件，通知仅会在切入点方法执行时被应用</li><li>连接点：JoinPoint，可以被AOP控制的方法。</li><li>通知：Advice，指哪些重复的逻辑，也就是共性功能，切面必须要完成的工作。（最终体现为一个方法)</li><li>切面：Aspect，描述通知与切入点的对应关系（通知+切入点) </li><li>目标对象：Target，通知所应用的对象</li><li>AOP最终执行的并非是原始的目标对象，而是基于目标对象自动生成的代理对象。</li><li>拿切西瓜来说<ul><li>连接点就是西瓜的任何地方</li><li>切入点表达式就是切西瓜的规则（例如只在西瓜的中间切）</li><li>切入点是真正被切的地方</li><li>通知是切西瓜前后的动作，比如切西瓜前的拿刀、切西瓜后的放刀。</li><li>切面可以是切西瓜的整个过程</li></ul></li></ul><h3 id="通知方法"><a href="#通知方法" class="headerlink" title="通知方法"></a>通知方法</h3><ul><li>@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行<ul><li>@Around环绕通知需要自己调用ProceedingJoinPoint.proceed(）来让原始方法执行，其他通知不需要考虑目标方法执行</li><li>@Around环绕通知方法的返回值，必须指定为0bject，来接收原始方法的返回值。</li></ul></li><li>@Before：前置通知，此注解标注的通知方法在目标方法前被执行</li><li>@After：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执</li><li>@AfterReturning：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执</li><li>@AfterThrowing：异常后通知，此注解标注的通知方法发生异常后执行</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>导入AOP依赖</li><li>定义通知类@Aspect，并将该类交给IOC容器管理（@Component）</li><li>定义通知方法（方法里面实现共性功能）</li><li>定义切入点@Pointcut(切入点表达式)和其依托的方法（切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑）</li><li>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置（通知方法）<ul><li>切入点表达式可以写在通知方法里面，这样第四步就可以省略了</li></ul></li><li>开启Spring对AOP注解驱动支持（@EnableAspectJAutoProxy）<ul><li>在springboot项目里面，可以省略第六步</li></ul></li></ol><h3 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h3><ul><li>当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。</li></ul><p>执行顺序</p><ol><li>不同切面类中，默认按照切面类的类名字母排序:<ul><li>目标方法前的通知方法:字母排名靠前的先执行</li><li>目标方法后的通知方法:字母排名靠前的后执行</li></ul></li><li>用@Order(数字)加在切面类上来控制顺序<ul><li>目标方法前的通知方法:数字小的先执行</li><li>目标方法后的通知方法:数字小的后执行</li></ul></li></ol><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><ul><li>切入点表达式:描述切入点方法的一种表达式</li><li>作用:主要用来决定项目中的哪些方法需要加入通知</li></ul><p>execution</p><ul><li>execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配</li><li>语法：execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数的全类名) 异常?)</li><li>其中带？的部分可以省略</li><li>注意,异常是方法上声明抛出的异常，不是实际抛出的异常</li><li>通配符<ul><li>*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分 </li><li>..：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</li></ul></li><li>根据业务需要，可以使用且(&amp;&amp;)、或()、非(!）来组合比较复杂的切入点表达式。</li></ul><p>@annotation</p><ul><li>@annotation切入点表达式，用于匹配标识有特定注解的方法。</li><li>特定注解是自己定义的</li><li>语法：@annotation(注解全类名)</li></ul><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><ul><li>概念：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败。</li><li>操作<ul><li>开启事务（一组操作开始前，开启事务) : start transaction &#x2F; begin ;</li><li>提交事务（这组操作全部成功后，提交事务): commit ;</li><li>回滚事务（中间任何一个操作出现异常，回滚事务) : rollback ;</li></ul></li></ul><p>spring事务管理</p><ul><li><p>注解：@Transactional</p><ul><li>位置：业务( service）层的方法上、类上、接口上</li><li>作用∶将当前方法交给spring进行事务管理，方法执行前，开启事务;成功执行完毕，提交事务;出现异常，回滚事务</li><li>注意<ul><li>默认情况下，只有出现RuntimeException 才回滚异常.</li></ul></li></ul></li><li><p>spring事务管理日志开关</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启spring事务管理日志开关</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.jdbc.support.JdbcTransactionManager:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li><li><p>@Transactional的属性</p><ul><li>rollbackFor：用于控制出现何种异常类型，回滚事务。<ul><li>如：@Transactional(rollbackFor &#x3D; Exception.class)，所有异常都会回滚事务</li></ul></li><li>propagation：可以控制事务的传播行为，其常用属性值如下<ul><li>REQUIRED：【默认值】需要事务，有则加入，无则创建新事务</li><li>REQUIRES_NEW：需要新事务，无论有无，总是创建新事务</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2024/04/30/Redis/"/>
      <url>/2024/04/30/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>官网：<a href="https://redis.io/">https://redis.io</a></li><li>教程网站：<a href="https://redis.net.cn/">https://redis.net.cn</a></li><li>Redis是一个基于<strong>内存</strong>的（key-value）结构数据库,也被称为结构化的NoSql数据库。<ul><li>NoSql(Not Only Sql)：泛指非关系型数据库。如：Redis、Mongodb</li></ul></li><li>应用场景：缓存、任务队列、消息队列、分布式锁</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型</p><ul><li>String：普通字符串，常用</li><li>hash：适合存储对象</li><li>list：按照插入顺序排序，可以有重复元素</li><li>set：无序集合,没有重复元素</li><li>sorted set：有序集合,没有重复元素</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><strong>SET</strong> key value：设置指定key的值</li><li><strong>GET</strong> key：获取指定key的值</li><li><strong>SETEX</strong> key seconds value：设置指定key的值，并将key的过期时间设为seconds秒</li><li><strong>SETNX</strong> key value：只有在 key不存在时设置key的值</li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Redis列表是简单的字符串列表，按照插入顺序排序</p><ul><li><p><strong>LPUSH</strong> key value1 [value2]：将一个或多个值插入到列表头部</p></li><li><p><strong>RPUSH</strong> key value1 [value2]：将一个或多个值插入到列表尾部</p></li><li><p><strong>LRANGE</strong> key start stop：获取列表指定范围内的元素</p><ul><li>lrange key 0 -1：获取列表中的所有元素</li></ul></li><li><p><strong>LPOP</strong> key  ：移除并获取列表第一个元素</p></li><li><p><strong>RPOP</strong> key：移除并获取列表最后一个元素</p></li><li><p>ltrim key 1 3: 保留[1,3]之间的元素，其他的删除</p></li><li><p><strong>LLEN</strong> key：获取列表长度</p></li><li><p><strong>BRPOP</strong> key1 [key2 ] timeout：移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</p></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Redis set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据</p><ul><li><strong>SADD</strong> key member1[member2]：向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key：返回集合中的所有成员</li><li><strong>SISMEMBER</strong> key member1：判断成员是否在集合中</li><li><strong>SCARD</strong> key：获取集合的成员数</li><li><strong>SREM</strong> key member1 [member2]：移除集合中一个或多个成员</li><li><strong>SINTER</strong> key1 [key2]：返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]：返回所有给定集合的并集</li><li><strong>SDIFF</strong> key1 [key2]：返回给定所有集合的差集</li></ul><h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p>Redis sorted set有序集合是string类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score)。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]：向有序集合添加一个或多个成员，或者更新已存在成员的分数</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]：通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZSCORE</strong> key member1：查看集合中成员的分数</li><li><strong>ZRANK</strong> key member1：查看集合中成员的排名（从小到大排）</li><li><strong>ZREVRANK</strong> key member1：查看集合中成员的排名（从大到小排）</li><li><strong>ZINCRBY</strong> key increment member：有序集合中对指定成员的分数加上增量increment</li><li><strong>ZREM</strong> key member [member …]：移除有序集合中的一个或多个成员</li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301737362.png" alt="image-20231128154558438"></p><ul><li><strong>HSET</strong> key field value：将哈希表key 中的字段field的值设为value</li><li><strong>HGET</strong> key field：获取存储在哈希表中指定字段的值</li><li><strong>HGETALL</strong> key：获取在哈希表中指定key的所有字段和值</li><li><strong>HDEL</strong> key field：删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key：获取哈希表中所有字段</li><li><strong>HVALS</strong> key：获取哈希表中所有值</li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><strong>KEYS</strong> pattern：查找所有符合给定模式( pattern)的key</li><li><strong>EXISTS</strong> key：检查给定key是否存在</li><li><strong>TYPE</strong> key：返回key所储存的值的类型</li><li><strong>TTL</strong> key：返回给定key的剩余生存时间(TTL, time to live)，以秒为单位</li><li><strong>DEL</strong> key：该命令用于在key存在是删除key</li><li>flushall：删除所有键</li><li>expire key：给键设置过期时间</li></ul><h2 id="Redis-高级"><a href="#Redis-高级" class="headerlink" title="Redis 高级"></a>Redis 高级</h2><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><ul><li>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</li><li>Redis 客户端可以订阅任意数量的频道。</li><li>当有新消息通过 PUBLISH 命令发送给频道时， 这个消息就会被发送给订阅它的客户端</li><li>局限性：消息无法持久化、无法记录历史消息</li></ul><p>订阅频道</p><ul><li>subscribe channel</li></ul><p>发布消息</p><ul><li>publish channel message</li></ul><h3 id="消息队列Stream"><a href="#消息队列Stream" class="headerlink" title="消息队列Stream"></a>消息队列Stream</h3><ul><li>Redis Stream 是 Redis 5.0 版本新增加的数据结构。主要用于消息队列（MQ，Message Queue）</li><li>Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</li></ul><h3 id="地理位置GEO"><a href="#地理位置GEO" class="headerlink" title="地理位置GEO"></a>地理位置GEO</h3><ul><li>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</li></ul><p>常用命令</p><ul><li><p>geoadd：添加地理位置的坐标。</p><ul><li>GEOADD key longitude latitude member [longitude latitude member …]</li></ul></li><li><p>geopos：从给定的 key 里返回所有指定名称(member)的位置（经度和纬度）</p><ul><li>GEOPOS key member [member …]</li></ul></li><li><p>geodist：用于返回两个给定位置之间的距离。</p><ul><li>GEODIST key member1 member2 [m|km|ft|mi]</li></ul></li><li><p>georadius ：以给定的经纬度为中心， 返回与中心的距离不超过给定最大距离的所有位置元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line"></span><br><span class="line">WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</span><br><span class="line">WITHCOORD: 将位置元素的经度和纬度也一并返回。</span><br><span class="line">COUNT 限定返回的记录数。</span><br><span class="line">ASC: 查找结果根据距离从近到远排序。</span><br><span class="line">DESC: 查找结果根据从远到近排序。</span><br></pre></td></tr></table></figure></li><li><p>georadiusbymember：以给定的位置元素为中心，返回与中心的距离不超过给定最大距离的所有位置元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure></li></ul><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><ul><li>Redis HyperLogLog 是用来做基数统计的算法</li><li>基数就是集合中唯一且不重复的元素个数，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数为5</li><li>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</li><li>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。</li></ul><p>常用命令</p><ul><li>PFADD：添加指定元素到 HyperLogLog 中。<ul><li>PFADD key element [element …]</li></ul></li><li>pfcount：返回给定 HyperLogLog 的基数估算值。<ul><li>PFCOUNT key [key..]</li></ul></li><li>pfmerge：将多个 HyperLogLog 合并为一个 HyperLogLog<ul><li>PFCOUNT destkey sourcekey [sourcekey,,,]</li></ul></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证<ul><li>在执行EXEC命令前，所有的命令都会被放入到一个队列中缓存起来，不会立即执行</li><li>在执行EXEC命令后，事务开始执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul></li><li>一个事务从开始到执行会经历以下三个阶段：开始事务-命令入队、执行事务</li></ul><p>事务命令</p><ul><li>MULTI：开启事务</li><li>EXEFC：执行事务</li><li>DISCARD：取消事务</li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul><li>内存存储有个问题就是关闭服务或者断电会丢失，Redis的数据也支持写到硬盘中，这个过程就叫做持久化。</li></ul><p>redis持久化的方式</p><ul><li><strong>RDB（Redis DataBase）</strong> ：在指定的时间间隔内，定时的将 redis 存储的数据生成Snapshot快照并存储到磁盘等介质上</li><li><strong>AOF（Append Of File）</strong> ：将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</li><li>同时允许使用两种方式，AOF的优先级更高。</li></ul><p>RDB</p><ul><li>备份文件的名称默认为dump.rdb</li><li>触发RDB备份的方式<ol><li>自动备份，需配置备份规则</li><li>手动执行命令备份（save和bgsave）<ul><li><code>save</code>：save时只管保存，其他不管，全部阻塞，手动保存，不建议使用。</li><li><code>bgsave</code>：redis会在后台异步进行快照操作，快照同时还可以响应客户端情况。</li></ul></li></ol></li></ul><p>AOF</p><ul><li>开启方式：在配置文件中将appendonly no改成appendonly yes</li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul><li>主从复制就是将主节点（master）redis的数据同步到其他从节点（slave）redis数据库上。实现高可用</li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><ul><li>当主机宕机后，需要手动把一台从（slave）服务器切换为主服务器，这就需要人工干预，费时费力，还回造成一段时间内服务不可用，这种就有了哨兵模式</li><li>哨兵集群。基于主从复制模式，所有的主从配置优点，它都有。</li><li>主从可以切换，故障可以转移，系统可用性就更好。</li><li>哨兵模式是主从模式的升级，手动到自动，更完善。</li></ul><h2 id="Java中的Redis"><a href="#Java中的Redis" class="headerlink" title="Java中的Redis"></a>Java中的Redis</h2><ul><li>Redis的Java客户端很多，官方推荐的有三种：Jedis、Lettuce、Redisson</li><li>Spring 对Redis客户端进行了整合，提供了Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即spring-boot-starter-data-redis</li></ul><h3 id="Jedis-不常用"><a href="#Jedis-不常用" class="headerlink" title="Jedis(不常用)"></a>Jedis(不常用)</h3><p>maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现步骤</p><ol><li><p>获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;主机名&quot;</span>,端口号);</span><br></pre></td></tr></table></figure></li><li><p>执行操作….</p></li><li><p>关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li></ol><h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h3><p>使用步骤</p><ol><li><p>导入Spring Data Redis 的maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Redis数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置类，创建RedisTemplate对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建redis模板对象...&quot;</span>);</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        <span class="comment">//设置redis的连接工厂对象</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//设置redis key的序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过RedisTemplate对象操作Redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure></li></ol><p>通用操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keys  exists  type    del</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//keys(keys)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line"></span><br><span class="line"><span class="comment">//exists(hashKey)</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">boolName</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">boolZzz</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;zzz&quot;</span>);</span><br><span class="line">System.out.println(boolName);</span><br><span class="line">System.out.println(boolZzz);</span><br><span class="line"></span><br><span class="line"><span class="comment">//type(type)</span></span><br><span class="line"><span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">    <span class="type">DataType</span> <span class="variable">type</span> <span class="operator">=</span> redisTemplate.type(key);</span><br><span class="line">    System.out.println(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//del(delete)</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;zset1&quot;</span>);</span><br></pre></td></tr></table></figure><p>操作String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set   get setex   setnx</span></span><br><span class="line"><span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//set(set)</span></span><br><span class="line">valueOperations.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jybzzz&quot;</span>);</span><br><span class="line"><span class="comment">//get(get)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) valueOperations.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//setex(set)</span></span><br><span class="line">valueOperations.set(<span class="string">&quot;code&quot;</span>,<span class="number">1234</span>,<span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//setnx(setIfAbsent)</span></span><br><span class="line">valueOperations.setIfAbsent(<span class="string">&quot;lock&quot;</span>,<span class="number">1</span>);</span><br><span class="line">valueOperations.setIfAbsent(<span class="string">&quot;lock&quot;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>操作hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hset  hget    hdel    hkeys   hvals</span></span><br><span class="line"><span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line"><span class="comment">//hset(put)</span></span><br><span class="line">hashOperations.put(<span class="string">&quot;student&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jybzzz&quot;</span>);</span><br><span class="line">hashOperations.put(<span class="string">&quot;student&quot;</span>,<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;male&quot;</span>);</span><br><span class="line">hashOperations.put(<span class="string">&quot;student&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line"><span class="comment">//hget(get)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) hashOperations.get(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//hkeys(keys)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keys</span> <span class="operator">=</span> hashOperations.keys(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line"><span class="comment">//hvals(values)</span></span><br><span class="line"><span class="type">List</span> <span class="variable">values</span> <span class="operator">=</span> hashOperations.values(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">System.out.println(values);</span><br><span class="line"><span class="comment">//del(delete)</span></span><br><span class="line">hashOperations.delete(<span class="string">&quot;student&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br></pre></td></tr></table></figure><p>操作list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lpush lrange  rpop    llen</span></span><br><span class="line"><span class="type">ListOperations</span> <span class="variable">listOperations</span> <span class="operator">=</span> redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line"><span class="comment">//lpush(leftPushAll、lefPush)</span></span><br><span class="line">listOperations.leftPushAll(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">listOperations.leftPush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="comment">//lrange(range)</span></span><br><span class="line"><span class="type">List</span> <span class="variable">mylist</span> <span class="operator">=</span> listOperations.range(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(mylist);</span><br><span class="line"><span class="comment">//rpop(rightPop)</span></span><br><span class="line">listOperations.rightPop(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line"><span class="comment">//llen(size)</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> listOperations.size(<span class="string">&quot;mylist&quot;</span>);</span><br><span class="line">System.out.println(size);</span><br></pre></td></tr></table></figure><p>操作set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sadd smembers scard sinter sunion srem</span></span><br><span class="line"><span class="type">SetOperations</span> <span class="variable">setOperations</span> <span class="operator">=</span> redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//sadd(add)</span></span><br><span class="line">setOperations.add(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">setOperations.add(<span class="string">&quot;set2&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>);</span><br><span class="line"><span class="comment">//smembers(members)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> setOperations.members(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">System.out.println(set1);</span><br><span class="line"><span class="comment">//scard(size)</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> setOperations.size(<span class="string">&quot;set1&quot;</span>);</span><br><span class="line">System.out.println(size);</span><br><span class="line"><span class="comment">//sinter(intersect)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">intersect</span> <span class="operator">=</span> setOperations.intersect(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">System.out.println(intersect);</span><br><span class="line"><span class="comment">//sunion(union)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">union</span> <span class="operator">=</span> setOperations.union(<span class="string">&quot;set1&quot;</span>, <span class="string">&quot;set2&quot;</span>);</span><br><span class="line">System.out.println(union);</span><br><span class="line"><span class="comment">//srem(remove)</span></span><br><span class="line">setOperations.remove(<span class="string">&quot;set1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><p>操作sorted set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zadd zrange zincrby zrem</span></span><br><span class="line"><span class="type">ZSetOperations</span> <span class="variable">zSetOperations</span> <span class="operator">=</span> redisTemplate.opsForZSet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//zadd(add)</span></span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">10</span>);</span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">12</span>);</span><br><span class="line">zSetOperations.add(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">9</span>);</span><br><span class="line"><span class="comment">//zrange(range)</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">zset1</span> <span class="operator">=</span> zSetOperations.range(<span class="string">&quot;zset1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">System.out.println(zset1);</span><br><span class="line"><span class="comment">//zincrby(Score)</span></span><br><span class="line">zSetOperations.incrementScore(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">//zrem(remoce)</span></span><br><span class="line">zSetOperations.remove(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="SpringCache"><a href="#SpringCache" class="headerlink" title="SpringCache"></a>SpringCache</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul><li>spring cache是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</li><li>spring Cache提供了一层抽象，底层可以切换不同的cache实现。具体就是通过CacheManager接口来统一不同的缓存技术。</li><li>CacheManager是Spring提供的各种缓存技术抽象接口。</li><li>针对不同的缓存技术需要实现不同的CacheManager</li></ul><table><thead><tr><th>CacheManager</th><th>描述</th></tr></thead><tbody><tr><td>EhCacheCacheManager</td><td>使用EhCache作为缓存技术</td></tr><tr><td>GuavaCacheManager</td><td>使用Google的GuavaCache作为缓存技术</td></tr><tr><td>RedisCacheManager</td><td>使用Redis作为缓存技术</td></tr></tbody></table><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@EnableCaching</td><td>开启缓存注解功能（放在启动类上）</td></tr><tr><td>@Cacheable</td><td>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据;若没有数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td>@CachePut</td><td>将方法的返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><p>CachePut（cacheName&#x3D;xxx,key&#x3D;xxx）</p><ul><li><p>将方法返回值放入缓存</p></li><li><p>常见属性</p><ul><li><p>cacheName：缓存的名称，每个缓存名称下面可以有多个key</p></li><li><p>key：缓存的key</p></li></ul></li></ul><p>CacheEvict</p><ul><li>将一条或多条数据从缓存中删除</li><li>属性值<ul><li>cacheName：缓存的名称</li><li>key：缓存的key</li><li>allEntries：是否删除该缓存名称下的所有缓存</li></ul></li></ul><p>Cacheable（cacheName&#x3D;xxx,key&#x3D;xxx,condition&#x3D;xxx或unless）</p><ul><li><p>在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据;若没有数据，调用方法并将方法返回值放到缓存中</p></li><li><p>属性值</p><ul><li>cacheName：缓存的名称，每个缓存名称下面可以有多个key</li><li>key：缓存的key</li><li>condition：缓存条件缓存</li><li>unless：满足条件不缓存</li></ul></li></ul><h3 id="SpEL表达式"><a href="#SpEL表达式" class="headerlink" title="SpEL表达式"></a>SpEL表达式</h3><ul><li><p>Spring Expression Language</p></li><li><p>常用在SpringCache中各种注解的key获取。常见写法</p><ul><li>#方法返回值.xxx(推荐)</li><li>#p0.xxx<ul><li>0表示方法中的第一个参数，以此类推</li></ul></li><li>#result.xxx</li><li>#root.args[0].xxx<ul><li>0表示方法中的第一个参数，以此类推</li></ul></li></ul></li></ul><h3 id="使用Redis作用缓存"><a href="#使用Redis作用缓存" class="headerlink" title="使用Redis作用缓存"></a>使用Redis作用缓存</h3><ul><li>该框架的底层是基于Map实现的，当服务关闭之后缓存就不存在了。所以要改成redis缓存</li></ul><p>坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">        <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">redis:</span></span><br><span class="line">            <span class="attr">time-to-live:</span> <span class="number">1800000</span> <span class="comment">#设置缓存过期时间</span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/2024/04/30/MybatisPlus/"/>
      <url>/2024/04/30/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h1><p>建议一些很简单的crud可以用mp写，稍微复杂一点点带各种参数和范围的在dao里面写，很复杂的动态sql就用xml写</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>官网：<a href="https://mybatis.plus/">https://mybatis.plus/</a> 或者<a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a></p></li><li><p>MyBatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提高效率</p></li><li><p>特性</p><ul><li>无侵入︰只做增强不做改变，不会对现有工程产生影响</li><li>强大的CRUD操作:内置通用Mapper，少量配置即可实现单表CRUD操作</li><li>支持Lambda：编写查询条件无需担心字段写错</li><li>支持主键自动生成</li><li>内置分页插件</li></ul></li></ul><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><ol><li>导坐标</li><li>在dao层对应的接口中写@Mapper，继承BaseMapper＜Pojo类＞即可</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>数据库的表名要和实体类类名（实体类类名）一样</p></li><li><p>表中的主键id要改成bigint类型，实体类中的id要改成Long类型</p></li><li><p>分页查询时要添加分页查询的拦截器</p></li></ul><h2 id="映射匹配兼容性"><a href="#映射匹配兼容性" class="headerlink" title="映射匹配兼容性"></a>映射匹配兼容性</h2><ul><li>表中字段名和类中的属性名不一样，在类对应的属性上方添加<ul><li>@TableField(value&#x3D;“表中对应的字段名”)</li></ul></li><li>类中添加了数据库中未定义的属性，在类对应的属性上方添加<ul><li>@TableField(exist &#x3D; false)</li></ul></li><li>数据库的表名和类名不一样，在类名上方添加<ul><li>@TableName(“数据库中对应的表名”)</li></ul></li></ul><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>普通条件查询</p><ol><li>创建一个条件查询对象：LambdaQueryWrapper＜Pojo类＞ 条件对象名&#x3D;new LambdaQueryWrapper＜Pojo类＞()</li><li>配合lambda表达式和mybatisplus的提供的条件查询函数写条件进行查询</li></ol><ul><li><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetByCondition</span><span class="params">()</span>&#123;</span><br><span class="line">    LambdaQueryWrapper&lt;People&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//条件：小于20岁</span></span><br><span class="line">    <span class="comment">//lqw.lt(People::getAge,20);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件：20岁-30岁之间</span></span><br><span class="line">    <span class="comment">//lqw.lt(People::getAge,30).gt(People::getAge,20);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件：小于20或者大于30</span></span><br><span class="line">    lqw.lt(People::getAge,<span class="number">20</span>).or().gt(People::getAge,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(peopleDao.selectList(lqw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>条件查询null值判断</p><ul><li>在条件查询函数前添加一个Boolean值判断的条件即可</li></ul><h2 id="MP和Sql的对应"><a href="#MP和Sql的对应" class="headerlink" title="MP和Sql的对应"></a>MP和Sql的对应</h2><p>官网：<a href="https://baomidou.com/pages/10c804/#between">https://baomidou.com/pages/10c804/#between</a></p><ul><li><p>lt() 等价于 &lt;</p></li><li><p>gt() 等价于 &gt;</p></li><li><p>le() 等价于 &lt;&#x3D;</p></li><li><p>ge() 等价于 &gt;&#x3D; </p></li><li><p>eq() 等价于 &#x3D;</p></li><li><p>between() 等价于 betwen</p></li><li><p>. 等价于 and</p></li><li><p>or() 等价于 or</p></li><li><p>likeLeft 等价于 %like</p></li><li><p>likeRight 等价于 like%</p></li></ul><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>增</p><ul><li>insert(entity)</li></ul><p>删除</p><ul><li><p>deleteById(id)：根据id删除记录</p></li><li><p>deleteBatchIds(ids)：根据传入List集合中的id进行批量删除</p></li><li><p>delete(queryWrapper)：更具条件删除</p></li><li><p>deleteByMap(map)：根据Map中的条件进行删除，map中的条件在sql语句中是and关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;emp_gender&quot;</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;emp_name&quot;</span>,<span class="string">&quot;卢家业&quot;</span>);</span><br><span class="line">employeeMapper.deleteByMap(map);</span><br><span class="line"><span class="comment">//等价于 delete from employee where emp_gender=“男” and emp_name=“卢家业”</span></span><br></pre></td></tr></table></figure></li></ul><p>查</p><ul><li><p>selectById(id)：根据id查询指定记录</p></li><li><p>selectBatchIds(ids)：批量查询指多个id的记录集合</p></li><li><p>selectByMap(map)：根据Map集合中传入的条件进行查询，每个条件都是and关系</p></li><li><p>selectOne(queryWrapper)：更具条件查询一条符合的数据</p></li><li><p>selectList(queryWrapper)：更具条件查询全部符合的数据</p></li><li><p>selectPage(page,queryWrapper)：更具分页条件和查询条件分页查询（记得要先搞分页查询的拦截器MybatisPlusInterceptor）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Course&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(Course::getCourseName,<span class="string">&quot;卢家业&quot;</span>);</span><br><span class="line">Page&lt;Course&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">courseBaseMapper.selectPage(page, queryWrapper);</span><br><span class="line"><span class="comment">//等价于 SELECT * FROM course WHERE course_name = “卢家业” LIMIT 0, 10;</span></span><br></pre></td></tr></table></figure></li></ul><p>改</p><ul><li>updateById(entity)：根据id进行记录更新，如果对象属性未传值，则不会更新该字段，保持数据库表原来字段值</li><li>update(entity,wrapper)：更具更新条件wrapper进行更新。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>id生成策略控制</p><ul><li>@TableId(type &#x3D; IdType.需要的生成策略)</li></ul><p>逻辑删除</p><ul><li>逻辑删除：为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中</li><li>@TableLogic(value &#x3D; “默认值”,delval &#x3D; “删除后的值”)</li></ul><p>乐观锁</p><ul><li>作用：防止业务并发现象带来的问题</li><li>步骤<ul><li>在数据库中添加乐观锁标记字段</li><li>实体类中添加对应字段，并设定当前字段为逻辑删除标记字段（@Version）</li><li>配置乐观锁拦截器实现锁机制对应的动态SQL语句拼装（OptimisticLockerInnerInterceptor）</li><li>使用乐观锁机制在修改前必须先获取到对应数据的verion方可正常进行</li></ul></li></ul><p>代码生成器</p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2024/04/30/Mybatis/"/>
      <url>/2024/04/30/Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>MyBatis是一款优秀的持久层框架，用于简化JDBC的开发。</li><li>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a><ul><li><a href="https://mybatis.net.cn/getting-started.html">https://mybatis.net.cn/getting-started.html</a></li></ul></li></ul><h2 id="Mybatis入门"><a href="#Mybatis入门" class="headerlink" title="Mybatis入门"></a>Mybatis入门</h2><ol><li><p>准备工作(创建springboot工程、数据库表、实体类)</p></li><li><p>引入Mybatis的相关依赖，配置Mybatis(数据库连接信息)</p><ul><li>相关依赖就是MyBatis Framework和MySQL Driver。如果是springboot工程可以在创建项目时直接勾选即可</li><li>基础配置，在resource文件夹下的application文件进行配置</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#驱动类名称</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库连接url</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="comment">#连接数据库的用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#连接数据库的密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment">#开启mybatis的日志，指定输出到控制台</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"><span class="comment">#开启mybatis的驼峰命名自动映射开关</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li><li><p>编写SQL语句(注解&#x2F;XML)</p><ul><li>@Mapper注解，会自动生成该接口的实现类对象(代理对象)，并且将该对象交给IOC容器管理</li></ul></li></ol><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ul><li>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</li><li>优势<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li><li>标准接口：DataSource，是官方(sun)提供的数据库连接池接口，由第三方组织实现此接口。</li><li>常见数据库连接池产品（都是实现了DataSource接口的）<ul><li>Hikri，springboot默认的</li><li>Druid，阿里巴巴开源的数据库连接池项目<ul><li>官网：<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></li><li>更改连接池只需在pom.xml文件中引入对应的依赖</li></ul></li></ul></li></ul><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><ul><li><p>参数占位符#{}</p><ul><li>执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值。使用时机:参数传递，都使用#{…}</li></ul></li><li><p>参数占位符${}</p><ul><li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题。使用时机:如果对表名、列表进行动态设置时使用。</li></ul></li><li><p>预编译的好处：性能更高，更安全(防止SQL注入)</p></li><li><p>SQL注入：SQL注入是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。</p></li><li><p>主键返回：@Options(keyProperty&#x3D;”id”,useGeneratedKeys&#x3D;true)</p><ul><li>会自动将生成的主键值，赋值给emp对象的id属性</li></ul></li><li><p>数据封装</p><ul><li>起别名:在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样。</li><li>手动结果映射:通过@Results及@Result进行手动结果映射。</li><li>开启驼峰命名:如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射。</li></ul></li></ul><h2 id="sql语句的定义"><a href="#sql语句的定义" class="headerlink" title="sql语句的定义"></a>sql语句的定义</h2><p>方法一：注解映射定义</p><ul><li>直接在Mapper接口类中添加注解</li></ul><p>方法二：xml映射定义</p><ul><li><p>创建一个xml文件进行配置</p></li><li><p>xml映射文件规范</p><ul><li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(同包同名)。</li><li>XML映射文件的namespace属性为Mapper接口的全类名。</li><li>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。</li></ul><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender=#&#123;gender&#125; and</span><br><span class="line">        entrydate between #&#123;start&#125; and #&#123;end&#125; order by update_time desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>resultType:单条记录所封装类型的全类名</li></ul></li><li><p>xml配置文件约束（官网和网上都可以找到）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>随着用户的输入或外部条件的变化而变化的SQL语句，我们称为动态SQL。</p><ul><li>＜if test&#x3D;”条件”＞＜&#x2F;if＞：用于判断条件是否成立。使用test&#x3D;”条件”属性进行条件判断，如果条件为true，则拼接SQL</li><li>＜where＞＜where＞：where元素只会在子元素有内容的情况下才插入where子句。而且会自动去除子句的开头的AND或OR。</li><li>＜set＞＜&#x2F;set＞：动态地在行首插入SET关键字，并会删掉额外的逗号。(用在update语句中)<ul><li>＜foreach collection&#x3D;”要遍历的集合” item&#x3D;”遍历出来的元素” separator&#x3D;”分隔符” open&#x3D;”遍历开始前拼接的sql片段” close&#x3D;”遍历结束后拼接的sql片段”＞＜&#x2F;foreach＞</li></ul></li><li>＜sql id&#x3D;”xxx”＞＜&#x2F;sql＞：定义可重用的SQL片段。</li><li>＜include refid&#x3D;”xxx”＞＜＞：通过属性refid，指定包含的sql片段。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见面试题</title>
      <link href="/2024/04/29/%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/04/29/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ul><li>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。</li></ul><p>String</p><ul><li>String 由 char[] 数组构成，使用了 final 修饰，对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。</li></ul><p>StringBuffer</p><ul><li>StringBuffer可变并且线程安全</li></ul><p>StringBuilder</p><ul><li>StringBuilder可变但线程不安全。</li></ul><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>equals和&#x3D;&#x3D;</p><ul><li>quals是Object的方法，默认比较的是对象的地址值。可以通过重写从而比较的对象的值。如String</li><li>“&#x3D;&#x3D;”是运算符，如果是基本数据类型，则比较存储的值；如果是引用数据类型，则比较所指向对象的地址值。</li></ul><p>equals和hashCode</p><ul><li>hashCode()默认是通过地址来计算hash码，可以通过重写从而通过对象的值计算hash码</li><li>若两个对象相等，他们的hashCode和equals一定相等</li><li>hashCode相等的两个对象未必相等</li><li>重写equals()必须重写hashCode()，比如在HashMap中，key如果是String类型，String如果只重写了equals（）而没有重写hashcode（）的话，则两个equals()比较为true的key，因为hashcode不同导致两个key没有出现在一个索引上，就会出现map中存在两个相同的key</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全</li></ul><p>扩容机制</p><ul><li>HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树</li></ul><p>存取原理</p><ul><li>计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置</li><li>如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）</li></ul><p>怎么用线程安全的HashMap</p><ul><li>使用ConcurrentHashMap</li><li>使用HashTable</li><li>Collections.synchronizedHashMap()方法</li></ul><p>ConcurrentHashMap原如何保证的线程安全</p><ul><li>JDK1.7:使用分段锁，将一个Map分为了16个段，每个段都是一个小的hashmap，每次操作只对其中一个段加锁</li><li>JDK1.8:采用CAS+Synchronized保证线程安全，每次插入数据时判断在当前数组下标是否是第一次插入，是就通过CAS方式插入，然后判断f.hash是否&#x3D;-1，是的话就说明其他线程正在进行扩容，当前线程也会参与扩容；删除方法用了synchronized修饰，保证并发下移除元素安全</li></ul><p>HashTable与HashMap的区别</p><ul><li>HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低</li><li>HashTable的Key不允许为null</li><li>HashTable只对key进行一次hash，HashMap进行了两次Hash</li><li>HashTable底层使用的数组加链表</li></ul><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList和LinkedList的区别</p><ul><li>ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；因为数组在内存中是连续的地址，所以ArrayList查找数据更快，由于扩容机制添加数据效率更低</li><li>LinkedList的底层使用链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据时需要从头遍历，所以查找慢，但是添加数据效率更高</li></ul><p>如何保证ArrayList的线程安全</p><ul><li>使用collentions.synchronizedList（）方法为ArrayList加锁</li><li>使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢</li><li>使用juc下的CopyOnWriterArrayList，该类实现了读操作不加锁，写操作时为list创建一个副本，期间其它线程读取的都是原本list，写操作都在副本中进行，写入完成后，再将指针指向副本。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>什么是反射</p><ul><li>反射是通过获取类的class对象，然后动态的获取到这个类的内部结构（成员变量、方法、构造器等），从而动态的去操作类的属性和方法。</li></ul><p>获取class对象的方法有</p><ul><li>class.forName(类路径)</li><li>类.class()</li><li>对象的getClass（）</li></ul><p>应用场景</p><ul><li>做框架</li><li>要操作权限不够的类属性和方法时</li><li>实现自定义注解时</li><li>动态加载第三方jar包时</li><li>按需加载类</li><li>节省编译和初始化时间</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>面向对象和面向过程的区别</p><ul><li>面向对象有封装、继承、多态性的特性，所以相比面向过程易维护、易复用、易扩展</li><li>但是因为类调用时要实例化，所以开销大性能比面向过程低</li></ul><p>多态的作用</p><ul><li>多态的实现要有继承、重写，父类引用指向子类对象。</li><li>可以消除类型之间的耦合关系，增加类的可扩充性和灵活性。</li></ul><p>Java创建对象得五种方式</p><ol><li>new</li><li>Class.newInstance</li><li>Constructor.newInstance</li><li>Clone</li><li>反序列化</li></ol><p>深拷贝和浅拷贝</p><ul><li>浅拷贝：浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存</li><li>深拷贝：深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。</li></ul><h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="分页插件的原理"><a href="#分页插件的原理" class="headerlink" title="分页插件的原理"></a>分页插件的原理</h2><ul><li>首先分页参数放到ThreadLocal中</li><li>拦截器拦截执行的sql，根据数据库类型添加对应的分页语句重写sql</li></ul><p>例如</p><ul><li>select * from table where xxx 会转为 select count(*) from table where xxx 和 select * from where xxx limit</li><li>从而计算出total总条数、pageNum当前页码、pageSize每页大小、以及当前页数据、是否为首尾页、总页数等信息</li></ul><h2 id="ResultType和ResultMap"><a href="#ResultType和ResultMap" class="headerlink" title="ResultType和ResultMap"></a>ResultType和ResultMap</h2><ul><li>ResultType：指定映射类型，只要查询的字段名和类型的属性名匹配可以自动映射。</li><li>ResultMap：自定义映射规则，当查询的字段名和映射类型的属性不匹配时可以通过ResultMap自定义映射规则也可以实现一对多、—对一映射。</li></ul><p>#{}和${}</p><ul><li>#{}：属于占位符，相当于？，可以防止sql注入</li><li>${}：用于在动态sql中拼接字符串，可能导致sql注入</li></ul><h1 id="cookie、session、token"><a href="#cookie、session、token" class="headerlink" title="cookie、session、token"></a>cookie、session、token</h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301739740.png" alt="image-20240407134601296"></p><ul><li>特点：存储在客户端、帮助在客户端和服务器之间维护状态信息</li><li>缺点：有被窜改的风险、容量限制为4kb，用户可以通过浏览器禁用cookie</li></ul><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p> <img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301739317.png" alt="image-20240407134933662"></p><ul><li>特点：存储在服务器、可以保存对象</li><li>缺点：占用服务器资源、扩展性差(分布式集群)、依然需要依赖cookie、存在跨越限制</li></ul><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>jwt令牌（json web token）</p><ul><li>由三段信息组成：header.payload.signature<ul><li>header(头)：包含了签名算法和token类型</li><li>payload(负载数据)：包含了数据</li><li>signature(签名密钥)：包含了经过base64编码后的header和payload，以及私钥</li></ul></li></ul><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301739015.png" alt="image-20240407142556278"></p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h2><ul><li>InnoDB1</li><li>支持事务。</li><li>使用的锁粒度默认为行级锁，可以支持更高的并发;也支持表锁。</li><li>支持外键约束;外键约束其实降低了表的查询速度，增加了表之间的耦合度。</li><li>MyISAM<ul><li>不提供事务支持</li><li>只支持表级锁</li><li>不支持外键</li></ul></li><li>memory<ul><li>数据存储在内存中总结</li></ul></li></ul><p>总结·</p><ul><li>MylISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作，应该选择MyISAM</li><li>InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</li></ul><h2 id="建表时的注意事项"><a href="#建表时的注意事项" class="headerlink" title="建表时的注意事项"></a>建表时的注意事项</h2><ol><li>注意选择存储引擎，如果要支持事务需要选择lnnoDB。</li><li>注意字段类型的选择<ul><li>对于日期类型如果要记录时分秒建议使用datetime，只记录年月日使用date类型</li><li>对于字符类型的选择，固定长度字段选择char，不固定长度的字段选择varchar，varchart比char节省空间但速度没有char快;</li><li>对于内容介绍类的长广文本字段使用text或longtext类型;</li><li>如果存储图片等二进制数据使用blob或longblob类型;</li><li>对金额字段建议使用DECIMAL;</li><li>对于数值类型的字段在确保取值范围足够的前提下尽量使用占用空间较小的类型，</li></ul></li><li>主键字段建议使用自然主键，不要有业务意义，建议使用int unsigned类型，特殊场景使用bigint类型。</li><li>如果要存储text、blob字段建议单独建一张表，使用外键关联。</li><li>尽量不要定义外键，保证表的独立性，可以存在外键意义的字段。</li><li>设置字段默认值，比如:状态、创建时间等。</li><li>每个字段写清楚注释。</li><li>注意字段的约束，比如:非空、唯一、主键等。</li></ol><h2 id="树形表查询"><a href="#树形表查询" class="headerlink" title="树形表查询"></a>树形表查询</h2><p>树型表的标记字段是什么？</p><ul><li>树型表的标记字段是parentid即父结点的id。</li></ul><p>如何查询Mysql树型表？</p><ol><li>当层级固定时可以用表的自链接进行查询。</li><li>如果想灵活查询每个层级可以使用mysql递归方法，使用with RECURSIVE 实现。（with RECURSIVE是mysql8之后才出现的）</li></ol><h1 id="数据对象模型"><a href="#数据对象模型" class="headerlink" title="数据对象模型"></a>数据对象模型</h1><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301739035.png" alt="image-20240410154617740"></p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301739805.png" alt="image-20240410154753256"></p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301739392.png" alt="image-20240410154802025"></p><h2 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h2><ul><li>VO（View Object）视图对象，<em><strong>通常用于表示一个业务实体或者页面展示的内容。</strong></em></li><li>通常用在前端和controller层的交互</li><li>如果是一个DTO对应一个VO，则DTO等价于VO，但是如果一个DTO对应多个VO，则展示层需要把VO转换为服务层对应方法所要求的DTO</li><li>VO通常包含了多个属性，并且这些属性的类型和名称与业务相关。</li><li>VO并不一定与数据库中的表结构相同，也不一定包含所有的属性。</li></ul><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h2><ul><li>DTO（Data Transfer Object）数据传输对象</li><li>通常用在controller层和service层</li><li>如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</li></ul><h2 id="PO"><a href="#PO" class="headerlink" title="PO"></a>PO</h2><ul><li>PO（Persistent Object）持久化对象，通常用于<em><strong>表示数据库中的表结构以及与之对应的实体类</strong></em></li><li>通常用在dao层（数据访问层）</li><li>PO通常包含了多个属性和对应的getter&#x2F;setter方法，属性的类型和名称与表结构相对应。</li><li>将数据库中的数据映射为Java对象，方便程序对数据的操作。</li></ul><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="项目开发流程"><a href="#项目开发流程" class="headerlink" title="项目开发流程"></a>项目开发流程</h2><ol><li>产品人员设计产品原型。</li><li>讨论需求。</li><li>分模块设计接口。</li><li>出接口文档。</li><li>将接口文档给到前端人员，前后端分离开发。</li><li>开发完毕进行测试。</li><li>测试完毕发布项目，由运维人员进行部署安装。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 大厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Elementui-Nginx</title>
      <link href="/2024/04/29/Vue/"/>
      <url>/2024/04/29/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Vue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写</li><li>框架:是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。基于框架进行开发更加快捷、更加高效</li><li>基于MVVM(Model-View-ViewModel)思想，实现数据的双向绑定</li></ul><h2 id="Vue项目的创建"><a href="#Vue项目的创建" class="headerlink" title="Vue项目的创建"></a>Vue项目的创建</h2><ul><li>环境要求：node.js、npm、Vue CLI</li></ul><p>使用VueCLI创建前端工程</p><ul><li>方式一：vue create 项目名称</li><li>方式二：vue ui（推荐）</li></ul><p>重点文件目录</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301737313.png" alt="image-20231204203935145"></p><ul><li><p>配置文件vue.config.js</p><ul><li><p>修改端口号</p></li><li><pre><code class="js">const &#123; defineConfig &#125; = require(&#39;@vue/cli-service&#39;)module.exports = defineConfig(&#123;  transpileDependencies: true,  devServer: &#123;    port: 7070  &#125;&#125;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- 配置代理(解决跨越问题)</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)</span><br><span class="line">  module.exports = defineConfig(&#123;</span><br><span class="line">    transpileDependencies: true,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      port: 7070,</span><br><span class="line">      proxy:&#123;</span><br><span class="line">          &#x27;/api&#x27;:&#123;</span><br><span class="line">              target:&#x27;http://localhost:8080&#x27;,</span><br><span class="line">              pathRewrite:&#123;</span><br><span class="line">                  &#x27;^/api&#x27;:&#x27;&#x27;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="Vue的基本使用"><a href="#Vue的基本使用" class="headerlink" title="Vue的基本使用"></a>Vue的基本使用</h2><p>vue组成</p><ul><li>vue组件由三个部分组成：template,script,style</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#结构：只有一个根元素，由它生成HTML代码</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">#逻辑：编写js代码，控制模板的数据来源和行为</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">#样式：编写css，全局样式、局部样式</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>文本插值</p><ul><li>作用：用来绑定data方法返回的对象属性</li><li>用法：{ { } }</li><li>如：<img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301737324.png" alt="image-20231204211612979"></li></ul><p>属性绑定</p><ul><li>作用：为标签的属性绑定data方法中返回的属性</li><li>用法：v-bind:xxx（简写为:xxx）</li><li>如：<img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301737795.png" alt="image-20231204211719188"></li></ul><p>事件绑定</p><ul><li>作用：为元素绑定对应的事件</li><li>用法：v-on:xxx（简写为@xxx）</li><li>如：<img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301737716.png" alt="image-20231204212528697"></li></ul><p>双向绑定</p><ul><li>作用：表单输入项和data方法中的属性进行绑定， 任意一方改变都会同步给另一方</li><li>用法：v-model</li><li>如：<img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301737689.png" alt="image-20231204213105753"></li></ul><p>条件渲染</p><ul><li>作用：根据表达式的值来动态渲染页面元素</li><li>用法：v-if&#x3D;xxx、v-else-if&#x3D;xxx、v-else</li><li>如：<img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738038.png" alt="image-20231204214632840"></li></ul><p>v-show：根据条件展示某元素，区别在于切换的是display属性的值</p><p>v-for：列表渲染,遍历容器的元素或者对象的属性</p><h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h2><p>介绍</p><ul><li>vue属于单页面应用，所谓的路由，就是根据浏览器路径不同，用不同的视图组件替换这个页面内容</li><li>路由：根据浏览器访问路径不同，展示不同的视图组件</li><li>库安装：npm install vue-router</li></ul><p>路由组成</p><ul><li><p>VueRouter：路由器，根据路由请求在路由视图中动态渲染对应的视图组件</p></li><li><p>＜router-link＞：路由链接组件，浏览器会解析成<a></p></li><li><p>＜router-view&#x2F;＞：路由视图组件，用来展示与路由路径匹配的视图组件</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738791.png" alt="image-20231205174213066"></p></li></ul><p>路由配置</p><ol><li><p>路由路径和视图对应关系</p><ul><li>在src-router-index.js文件下配置</li></ul><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738661.png" alt="image-20231205192010173"></p></li><li><p>＜router-link＞</p><ul><li>相当于超链接</li></ul><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738885.png" alt="image-20231205192341442"></p><ul><li>如果不用＜router-link＞，还可以用编程式的办法进行路由跳转<ul><li>this.$router.push(‘路径’)</li></ul></li></ul></li><li><p>＜router-view&#x2F;＞</p><ul><li>相当于占位符</li></ul></li></ol><ul><li><p>对应不存在的路由地址可统一处理，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:&#x27;/404&#x27;,</span><br><span class="line">  component: () =&gt; import(&#x27;../views/404View.vue&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path:&#x27;*&#x27;,</span><br><span class="line">  redirect:&#x27;/404&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>redirect可实现重定向</li></ul></li><li><p>路由嵌套（children）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path:&#x27;/c&#x27;,</span><br><span class="line">  component: () =&gt; import(&#x27;../views/container/ContainerView.vue&#x27;),</span><br><span class="line">  //嵌套路由（子路由）：对应的组件会展示在当前组件内部</span><br><span class="line">  children:[</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;/c/p1&#x27;,</span><br><span class="line">      component: () =&gt; import(&#x27;../views/container/P1View.vue&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;/c/p2&#x27;,</span><br><span class="line">      component: () =&gt; import(&#x27;../views/container/P2View.vue&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path:&#x27;/c/p3&#x27;,</span><br><span class="line">      component: () =&gt; import(&#x27;../views/container/P3View.vue&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>介绍</p><ul><li>vuex是一个专为Vue.js应用程序开发的状态管理库</li><li>vuex可以在多个组件之间共享数据，并且共享的数据是响应式的，即数据的变更能及时渲染到模板</li><li>vuex采用集中式存储管理所有组件的状态</li><li>安装：npm install vuex@next –save</li></ul><p>核心概念</p><ul><li>state：状态对象，集中定义各个组件共享的数据</li><li>mutations：类似于一个事件，用于修改共享数据，要求必须是同步函数</li><li>actions：类似于mutation，可以包含异步操作，通过调用mutation来改变共享数据</li></ul><p>使用方式</p><ul><li><p>定义和展示共享数据</p><ul><li>在state里面定义共享数据</li><li>通过来展示数据</li></ul><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738509.png" alt="image-20231205201028398"></p></li><li><p>在mutations中定义函数，修改共享数据</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738093.png" alt="image-20231205203315255"></p><ul><li>在外部文件下调用mutations中定义的函数：this.$store.<strong>commit</strong>(‘函数名’,参数)</li></ul></li><li><p>在actions中定义函数，用于调用mutation，实现异步修改共享数据</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738498.png" alt="image-20231205204843412"></p><ul><li>在外部文件下调用actions中定义的函数：this.$store.<strong>dispatch</strong>(‘函数名’)</li></ul></li></ul><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Ajax：Asynchronous JavaScript And XML，异步的JavaScript和XML</li><li>作用<ul><li>数据交换:通过Ajax可以给服务器发送请求，并获取服务器响应的数据。</li><li>异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术</li></ul></li></ul><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>介绍</p><ul><li><p>Axios是一个基于promise的网络请求库，作用于浏览器和nodejs 中</p></li><li><p>Axios对原生的Ajax进行了封装，简化书写，快速开发。</p></li><li><p>安装在终端输入：pip install axios</p></li><li><p>导入命令：import axios from ‘axios’</p></li><li><p>官网：<a href="https://www.axios-http.cn/">https://www.axios-http.cn/</a></p></li></ul><p>axios的API列表</p><table><thead><tr><th>请求</th><th></th></tr></thead><tbody><tr><td>axios.get(url[,config])</td><td></td></tr><tr><td>axios.delete(url[,config])</td><td></td></tr><tr><td>axios.head(url[,config])</td><td></td></tr><tr><td>axios.options(url[,config])</td><td></td></tr><tr><td>axios.post(url[,data[,config]])</td><td></td></tr><tr><td>axios.put(url[,data[,config]])</td><td></td></tr><tr><td>axios.patch(url[,data[,config]])</td><td></td></tr></tbody></table><ul><li>url：请求路径</li><li>data：请求体数据，最常见的是JSON格式数据</li><li>config：配置对象，可以设置查询参数、请求头信息</li><li>统一使用方式：axios(config)<ul><li>具体使用看：<a href="https://www.axios-http.cn/docs/req_config">https://www.axios-http.cn/docs/req_config</a></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url:&#x27;/api/employee/login&#x27;,</span><br><span class="line">    method:&#x27;post&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        username:&#x27;admin&#x27;,</span><br><span class="line">        password:&#x27;123456&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).then(res=&gt;&#123;</span><br><span class="line">    console.log(res.data)</span><br><span class="line">    &#125;).catch(error=&gt;&#123;</span><br><span class="line">    console.log(error.response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><ul><li>一套为开发者、设计师和产品经理准备的基于Vue 2.0的桌面端组件库</li><li>官网：<a href="https://element.eleme.cn/#/zh-CN/component/button">https://element.eleme.cn/#/zh-CN/component/button</a></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><p>安装ElementUI组件库(在当前工程的目录下)，在命令行执行指令:</p><ul><li><p>npm i element-ui -S</p></li><li><p>npm install element-ui#2.15.3</p></li></ul></li><li><p>在main.js文件下引入ElementUI组件库</p><ul><li>import ElementUI from ‘element-ui’;</li><li>import ‘element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css’;</li><li>Vue.use(ElementUI);</li></ul></li><li><p>访问官网，复制组件代码，调整</p></li></ol><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>TypeScript(简称:TS)是微软推出的开源语言</p></li><li><p>TypeScript 是JavaScript 的超集(JS有的TS都有)</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738087.png" alt="image-20231205205230616"></p></li><li><p>TypeScript &#x3D; Type + JavaScript(在JS基础上增加了类型支持)</p></li><li><p>TypeScript文件扩展名为ts</p></li><li><p>TypeScript可编译成标准的JavaScript，并且在编译时进行类型检查</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738877.png" alt="image-20231205205308057"></p></li><li><p>安装：npm install -g typescript（管理员执行cmd再执行）</p></li><li><p>TS为什么要增加数据类型？</p><ul><li>TS属于静态类型编程语言，JS属于动态类型编程语言</li><li>静态类型在编译期做类型检查，动态类型在执行期做类型检查</li><li>对于JS来说，需要等到代码执行的时候才能发现错误（晚)</li><li>配合VSCode 开发工具，TS 可以提前到在编写代码的同时就发现代码中的错误，减少找 Bug、改Bug 的时间</li></ul></li></ul><h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738426.png" alt="image-20231205211603894"></p><p>类型标注的位置</p><ul><li>标注变量</li><li>标注参数</li><li>标注返回值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">username</span>:<span class="built_in">string</span> = <span class="string">&#x27;ljy&#x27;</span></span><br><span class="line"><span class="comment">//数字</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">//布尔</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">isTrue</span>:<span class="built_in">boolean</span>=<span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(username,age,isTrue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printText</span>(<span class="params">s:<span class="built_in">string</span>,alignment:<span class="string">&#x27;left&#x27;</span>|<span class="string">&#x27;right&#x27;</span>|<span class="string">&#x27;cener&#x27;</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s,alignment)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printText</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&quot;left&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//interface类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>,</span><br><span class="line">    sex?:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">c1</span>:<span class="title class_">Cat</span>=&#123;<span class="attr">name</span>:<span class="string">&#x27;ljy&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>&#125; <span class="comment">//sex后面有？，所以可以不写</span></span><br><span class="line"><span class="comment">// const c2:Cat=&#123;name:&#x27;ljy&#x27;&#125;  //错误，缺少age属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//class类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">study</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;正在学习&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;卢家业&#x27;</span>)</span><br><span class="line">user.<span class="title function_">study</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实现接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">    <span class="title function_">eat</span>():<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">eat</span>():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b1 = <span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&#x27;燕子&#x27;</span>)</span><br><span class="line">b1.<span class="title function_">eat</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parrot</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Bird</span>&#123;</span><br><span class="line">    <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>+<span class="string">&quot;say hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1=<span class="keyword">new</span> <span class="title class_">Parrot</span>(<span class="string">&#x27;polly&#x27;</span>)</span><br><span class="line">p1.<span class="title function_">eat</span>()</span><br><span class="line">p1.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure><h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><ul><li>官网：<a href="https://nodejs.org/en">https://nodejs.org/en</a></li><li>查看是否安装成功：node -v</li><li>配置全局路径：管理员身份运行cmd –&gt; npm config set prefix ”nodejs的安装路径“</li><li>切换npm的淘宝镜像（为了下载东西更快）:npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li></ul><h2 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h2><ul><li>安装vue-cli：管理员身份运行cmd –&gt; npm install -g @vue&#x2F;cli</li><li>查看是否安装成功：vue –version</li><li>vue项目的创建<ol><li>管理员身份运行cmd –&gt;vue ui</li><li>点击创建 –&gt;在此创建项目</li><li>输入项目名称，选择包管理器，下一步</li><li>选择预设（手动），下一步</li><li>选择功能（Router），下一步</li><li>选择vue的版本，选择语法检测规范（第一个），创建项目</li></ol></li><li>vue项目的启动：在vue项目的cmd下执行：npm run serve</li><li>vue项目的打包：在vue项目的cmd下执行：npm run build（打包后会生成一个dist目录）</li></ul><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><ul><li>官网：<a href="https://nginx.org/">https://nginx.org/</a></li><li>介绍: Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器。</li><li>nginx适合部署静态资源</li><li>部署<ul><li>部署∶将打包好的dist目录下的文件，复制到nginx安装目录的html目录下。</li><li>启动:双击nginx.exe文件即可，Nginx服务器默认占用80端口号（可以在conf目录下找到nginx.conf修改端口号）</li></ul></li></ul><h2 id="反向代理技术"><a href="#反向代理技术" class="headerlink" title="反向代理技术"></a>反向代理技术</h2><ul><li><p>正向代理：一般是在客户端设置代理服务器，通过代理服务器转发请求，最终访问到目标服务器。</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738064.png" alt="image-20231130152011372"></p></li><li><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器负责将请求转发给目标服务器。</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738546.png" alt="image-20231130152217378"></p></li><li><p>将前端发送的动态请求由nginx转发到后端服务器</p></li><li><p>好处：提高访问速度，进行负载均衡，保证后端服务的安全</p><ul><li>负载均衡：所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器</li></ul></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul><li><p>当业务流量越大时，单台服务器的性能及单点故障问题就凸显出来了</p></li><li><p>因此需要多台服务器组成应用集群,进行性能的水平扩展以及避免单点故障出现。</p></li><li><p>负载均衡也是用反向代理技术来实现的</p></li><li><p>应用集群：将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</p></li><li><p>负载均衡器：将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738611.png" alt="image-20231130152617394"></p></li><li><p>负载均衡策略</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301738026.png" alt="image-20231130153442139"></p></li></ul><h2 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> #普通配置</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       90;#监听端口</span><br><span class="line">        server_name  localhost; #服务器名称</span><br><span class="line">        location / &#123;#匹配客户端请求url</span><br><span class="line">            root   html;#指定静态资源根目录</span><br><span class="line">            index  index.html index.htm;#指定默认首页</span><br><span class="line">            #proxy_passhttp://xxxx#配置反向代理服务器</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#反向代理配置</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       90;#监听端口</span><br><span class="line">        server_name  localhost; #服务器名称</span><br><span class="line">        location / &#123;#匹配客户端请求url</span><br><span class="line">            #proxy_passhttp://xxxx#配置反向代理服务器</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#负载均衡配置</span><br><span class="line"> upstream targetserver&#123;#upstream指令可以定义一组服务器</span><br><span class="line">server xxx#代理服务器1</span><br><span class="line">server xxx#代理服务器2</span><br><span class="line">&#125;</span><br><span class="line"> server &#123;</span><br><span class="line">        listen       90;#监听端口</span><br><span class="line">        server_name  localhost; #服务器名称</span><br><span class="line">        location / &#123;#匹配客户端请求url</span><br><span class="line">            #proxy_passhttp://targetserver#配置反向代理服务器</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端高级 Vue Nginx ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2024/04/29/Mysql/"/>
      <url>/2024/04/29/Mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="小黑框下的操作"><a href="#小黑框下的操作" class="headerlink" title="小黑框下的操作"></a>小黑框下的操作</h1><h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><ul><li>mysql -u用户名 -p密码 -h要连接的mysql服务器IP地址(默认是127.0.0.1) -p端口号(默认是3306)</li></ul><h2 id="退出mysql"><a href="#退出mysql" class="headerlink" title="退出mysql"></a>退出mysql</h2><ul><li>exit</li><li>quit</li></ul><h2 id="卸载mysql"><a href="#卸载mysql" class="headerlink" title="卸载mysql"></a>卸载mysql</h2><ol><li>net stop mysql</li><li>mysqld -remove mysql</li><li>删除mysql目录及相关的环境变量</li></ol><h1 id="SQL通用语句"><a href="#SQL通用语句" class="headerlink" title="SQL通用语句"></a>SQL通用语句</h1><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>单行注释：– 注释或#注释</li><li>多行注释：&#x2F;* 注释 *&#x2F;</li></ol><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><ul><li>DDL(Data Definition Language)数据定义语言，用来定义数据库对象︰数据库，表，列等</li></ul><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><ul><li><p>查询：show databases;（查询所有数据库）</p><p>​select database();（查询当前使用的数据库）</p></li><li><p>创建：create database 数据库名称;</p><p>​create database if not exists 数据库名称;</p></li><li><p>删除：drop database 数据库名称；</p><p>​drop database if exists 数据库名称；</p></li><li><p>使用：use 数据库名称;</p></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><ul><li><p>查询：show tables;（查询当前数据库下所有的表名称）</p><p>​desc 表名称;（查询表结构）</p><p>​ show create table 表名称（查看建表语句）</p></li><li><p>创建：create table 表名(</p><p>字段名1 数据类型1,</p><p>字段名2 数据类型2,</p><p>….</p><p>字段名n 数据类型n</p><p>);</p></li><li><p>删除：drop table 表名;</p><p>​            drop table if exists 表名;</p></li><li><p>修改：alter table 表名 <strong>rename</strong> <strong>to</strong> 新表名;（修改表名）</p><p>​            alter table 表名 <strong>add</strong> 列名 数据类型;（添加一列）</p><p>​            alter table 表名 <strong>modify</strong> 列名 新数据类型;（修改数据类型）</p><p>​            alter table 表名 <strong>change</strong> 列名 新列名 新数据类型；（修改列名和数据类型）</p><p>​            alter table 表名 <strong>drop</strong> 列名;（删除列）</p></li></ul><p>​</p><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><ul><li><p>DML(Data Manipulation Language)数据操作语言，用来对数据库中表的数据进行增删改</p></li><li><p>增加：insert into 表名(列名1,列名2,…) values(值1,值2,…);（给指定列添加数据）</p><p>​            insert into 表名 values(值1,值2,….值n);（给全部列添加数据） </p></li><li><p>删除：delete from 表名 [where 条件]; （删除数据）</p></li><li><p>修改：update 表名 <strong>set</strong> 列名1&#x3D;值1,列名2&#x3D;值2,… [where 条件];（修改数据）</p></li></ul><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><ul><li>DQL(Data Query Language)数据查询语言，用来查询数据库中表的记录(数据)</li></ul><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><ul><li>查询所有字段<ul><li>select * from 表名；</li></ul></li><li>查询指定字段<ul><li>select 字段列表 from 表名；</li></ul></li><li>去除重复记录（distinct）<ul><li>select distinct 字段列表 from 表名；</li></ul></li><li>起别名（as）<ul><li>select 字段 as 别名 from 表名；</li></ul></li></ul><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><ul><li><pre><code class="sql">select 字段列表 from 表名 where 条件列表；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 排序查询</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  select 字段列表 from 表名 order by 排序字段名1[排序方式1]，排序字段名2[排序方式2]...;</span><br></pre></td></tr></table></figure>排序方式：- 升序（默认）：asc- 降序：desc</code></pre></li><li><p>注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序</p></li></ul><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><ul><li>概念：将一列数据作为一个整体，进行纵向计算。</li><li>select 聚合函数（列名） from 表；</li><li>聚会函数：<ul><li>count（）：统计数量</li><li>max（）：最大值</li><li>min（）：最小值</li><li>sum（）：求和</li><li>aavg（）：平均值</li></ul></li><li>注意：null值不参与所有聚合函数运算</li></ul><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><ul><li><pre><code class="sql">select 字段列表 from 表名 [where 分组前条件限定] group by 分组字段名 [having 分组后条件过滤]；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 注意：</span><br><span class="line">  - 分组之后，查询的字段应为聚合函数和分组字段，查询其他字段无任何意义。</span><br><span class="line">  - 执行顺序：where&gt;聚合函数&gt;having</span><br><span class="line">  - where是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。</span><br><span class="line">  - 可判断的条件不一样: where不能对聚合函数进行判断，having可以。</span><br><span class="line"></span><br><span class="line">## 分页查询</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  select 字段列表 from 表名 limit 起始索引,查询条目数;</span><br></pre></td></tr></table></figure></code></pre></li><li>起始索引:从0开始</li><li>计算公式:起始索引&#x3D;(当前页码-1)*每页显示的条数</li></ul><h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><ul><li>DCL(Data Conttol Language)数据控制语言，用来定义数据库的访问权限和安全级别及创建用户</li></ul><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul><li>约束的概念：约束是作用于表中列上的规则，用于限制加入表的数据</li><li>约束的作用：约束的存在保证了数据库中数据的正确性、有效性和完整性</li><li>添加约束可以在建表时添加，也可以在建完表之后再添加</li></ul><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><ul><li>关键字：<strong>not null</strong></li><li>描述：保证列中所有数据不能有null值</li></ul><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><ul><li>关键字：<strong>unique</strong></li><li>描述：保证列中所有数据各不相同</li></ul><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><ul><li><p>关键字：<strong>primary key</strong></p></li><li><p>描述：主键是一行数据的唯一标识，要求非空且唯一</p></li><li><p>添加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">primary</span> key(字段名);</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure></li></ul><h2 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h2><ul><li>关键字：<strong>check</strong></li><li>描述：保证列中的值满足某一条件</li></ul><h2 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h2><ul><li><p>关键字：<strong>default</strong></p></li><li><p>描述：保存数据时，未指定值则采用默认值</p></li><li><p>添加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">alter</span> 列名 <span class="keyword">set</span> <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">alter</span> 列名 <span class="keyword">drop</span> <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ul><li><p>关键字：<strong>foreign key</strong></p></li><li><p>描述：外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</p></li><li><p>建表时添加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">constraint</span>] [外键名称] <span class="keyword">foreign</span> key(外键列名) <span class="keyword">references</span> 主表(主表列名)</span><br></pre></td></tr></table></figure></li><li><p>建完表之后添加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键列名)   <span class="keyword">references</span> 主表(主表列名)；</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> key 外键名称； </span><br></pre></td></tr></table></figure></li></ul><h2 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h2><ul><li>关键字：<strong>auto_increment</strong></li><li>注意：当列是数字类型并且唯一约束才能用</li></ul><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="软件的研发步骤"><a href="#软件的研发步骤" class="headerlink" title="软件的研发步骤"></a>软件的研发步骤</h2><ol><li>需求分析：（产品经理  -&gt;  产品原型）</li><li>设计：（架构师，开发工程师  -&gt;  软件结构设计，<strong>数据库设计</strong>，接口设计，过程设计）</li><li>编码：（开发工程师）</li><li>测试：（测试工程师）</li><li>安装部署（运维工程师）</li></ol><h2 id="数据库设计-1"><a href="#数据库设计-1" class="headerlink" title="数据库设计"></a>数据库设计</h2><ul><li>概念<ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的表<strong>结构</strong>以及表与表之间的关联<strong>关系</strong>的过程。</li><li>有哪些表?表里有哪些字段?表和表之间有什么关系?</li></ul></li><li>设计步骤<ol><li>需求分析（数据是什么?数据具有哪些属性?数据与属性的特点是什么)</li><li>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统)</li><li>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计)</li><li>维护设计（1.对新的需求进行建表;2表优化)</li></ol></li></ul><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><ul><li>一对一<ul><li>如：用户和用户详情</li><li>实现方式：在任意一方加入外键，关联另一方主键，并且设置<strong>外键为唯一</strong>(UNIQUE)</li></ul></li><li>一对多（多对一）<ul><li>如：部门和员工</li><li>实现方式：在<strong>多的一方</strong>建立外键，指向一的一方的主键</li></ul></li><li>多对多<ul><li>如：商品和订单</li><li>实现方式：建立第三张<strong>中间表</strong>，中间表至少包含两个外键，分别关联两方主键</li></ul></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接："><a href="#内连接：" class="headerlink" title="内连接："></a>内连接：</h3><ul><li><p>相当于查询表之间交集的数据</p></li><li><p>隐式内连接：</p><ul><li><pre><code class="sql">select 字段列表 from 表1，表2...where 条件；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 显示内连接：</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    select 字段列表 from 表1 [inner] join 表2 on 条件;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul><li><p>左外连接</p><ul><li><p>左外连接:相当于查询A表所有数据和交集部分数据</p></li><li><pre><code class="sql">select 字段列表 from 表1 left [outer] join 表2 on 条件;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 右外连接</span><br><span class="line"></span><br><span class="line">  - 右外连接:相当于查询B表所有数据和交集部分数据</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    select 字段列表 from 表1 right [outer] join 表2 on 条件;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul><li>查询中嵌套查询，称嵌套查询为子查询</li></ul><h3 id="多行单列"><a href="#多行单列" class="headerlink" title="多行单列"></a>多行单列</h3><ul><li><p>单行单列:作为条件值，使用&#x3D;!&#x3D;&gt;&lt;等进行条件判断</p></li><li><pre><code class="sql">select 字段列表 from 表 where 字段名 条件 （子查询）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 多行单列</span><br><span class="line"></span><br><span class="line">- 多行单列:作为条件值，使用in 等关键字进行条件判断</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  select 字段列表 from 表 where 字段名 in （子查询）</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="多行多列"><a href="#多行多列" class="headerlink" title="多行多列"></a>多行多列</h3><ul><li><p>多行多列：作为虚拟表</p></li><li><pre><code class="sql">select 字段列表 from（子查询）where 条件;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 组合查询</span><br><span class="line"></span><br><span class="line">### union</span><br><span class="line"></span><br><span class="line">- UNION 操作符合并两个或多个 SELECT 语句的结果。</span><br><span class="line"></span><br><span class="line">- 注意：UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</span><br><span class="line"></span><br><span class="line">- 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  SELECT column_name(s) FROM table1</span><br><span class="line">  UNION ALL</span><br><span class="line">  SELECT column_name(s) FROM table2;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>length(str)：计算字符串长度</li><li>reverse(str)：反转字符串</li><li>concat(str1,str2)：拼接字符串</li><li>concat_ws(分隔符,str1,array(str2,str3,…))：带分隔符拼接字符串</li><li>substr(str,开始位置,截取长度)：截取字符串</li><li>split(str,regex)：分割字符串（mysql没有此函数）</li><li>regexp运算符：是正则表达式（regular expression）的缩写，正则表达式在搜索字符串时非常强大<ul><li>^表示字符串开头</li><li>￥表示字符串结尾</li><li>|表示逻辑上的or，可以给出多个搜索模式</li><li>[]表示任意在括号里列举的单字符</li><li>[-]表示任意在括号内范围内的单字符</li></ul></li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul><li>current_date()：显示当前日期</li><li>datediff(‘date1’,’date2’)：计算日期差，日期格式要求”yyyy-MM-dd HH:mm:ss“ 或者”yyyy-MM-dd”</li><li>date_add(date,增加天数)：日期增加</li><li>date_sub(date,减少天数)：日期减少</li><li>day(date)：返回date中的day值</li><li>month(date)：返回date中的month值</li><li>year(date)：返回date中的year值</li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li>round(double a)：四舍五入取整</li><li>round(double a,int b)：保留b位小数</li><li>rand()：在0-1之间随机取值</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>if(boolean testCondition,True,FalseOrNull)：三元表达式</p></li><li><p>case的用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> 表达式<span class="number">1</span> <span class="keyword">then</span> 值<span class="number">1</span></span><br><span class="line"><span class="keyword">when</span> 表达式<span class="number">2</span> <span class="keyword">then</span> 值<span class="number">2</span></span><br><span class="line"><span class="keyword">when</span> 表达式<span class="number">3</span> <span class="keyword">then</span> 值<span class="number">3</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span> 其他值</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>nvl(value1,default_value)：空值转换函数</p></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><ul><li>数据库的事务（(Transaction）是一种机制、一个操作序列，包含了<strong>一组数据库操作命令</strong></li><li>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令<strong>要么同时成功，要么同时失败</strong></li><li>事务是一个<strong>不可分割</strong>的工作逻辑单元</li></ul><h2 id="事务的语法"><a href="#事务的语法" class="headerlink" title="事务的语法"></a>事务的语法</h2><ul><li><pre><code class="sql">begin; #开始事务 .....#要执行的操作commit;#提交事务rollback;#回滚事务</code></pre></li></ul><h2 id="事务的四大特征（ACID）"><a href="#事务的四大特征（ACID）" class="headerlink" title="事务的四大特征（ACID）"></a>事务的四大特征（ACID）</h2><ul><li><strong>原子性</strong>(Atomicity):事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li><strong>一致性</strong>(Consistency):事务完成时，必须使所有的数据都保持一致状态</li><li><strong>隔离性</strong>(lsolation):多个事务之间，操作的可见性</li><li><strong>持久性</strong>(Durability):事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul><li><p>索引(index)是帮助数据库高效获取数据的数据结构。</p></li><li><p>优点</p><ul><li>提高数据查询的效率,降低数据库的Io成本。</li><li>通过索引列对数据进行排序,降低数据排序的成本，降低CPU消耗。</li></ul></li><li><p>缺点</p><ul><li>索引会占用存储空间。</li><li>索引大大提高了查询效率，同时却也降低了insert、<br>update. delete的效率。</li></ul></li><li><p>结构</p><ul><li><p>MySQL数据库支持的索引结构有很多，如:Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的B+Tree结构组织的索引。</p></li><li><p>B+Tree(多路平衡搜索树)</p></li></ul></li><li><p>语法</p><ul><li>创建索引：create [ unique ] index 索引名 on 表名(字段名,…);</li><li>查看索引：show index from 表名；</li><li>删除索引：drop index  索引名 on 表名；</li></ul></li><li><p>注意</p><ul><li>主键字段，在建表时，会自动创建主键索引。</li><li>添加唯一约束时，数据库实际上会添加唯一索引</li></ul></li></ul><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>MNySQL主从复制是一个异步的复制过程，底层是基于Nysql数据库自带的二进制日志功能。</li><li>就是一台或多台MySQL数据库(slave，即从库)从另一台MysQL数据库(master，即主库）进行日志的复制然后再解析日志并应用到自身，最终实现从库的数据和主库的数据保持一致。</li><li>MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具。</li></ul><p>复制过程</p><ul><li>master将改变记录到二进制日志( binary log)</li><li>slave将master的binary log拷贝到它的中继日志( relay log)</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中</li></ul><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301736824.png" alt="image-20231130144345238"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HtmlCssJs</title>
      <link href="/2024/04/29/HtmlCssJs/"/>
      <url>/2024/04/29/HtmlCssJs/</url>
      
        <content type="html"><![CDATA[<h1 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h1><h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p>h</p><ul><li>＜h1＞1级标题＜&#x2F;h1＞</li><li>＜h2＞1级标题＜&#x2F;h2＞</li><li>＜h3＞1级标题＜&#x2F;h3＞</li><li>＜h4＞1级标题＜&#x2F;h4＞</li><li>＜h5＞1级标题＜&#x2F;h5＞</li><li>＜h6＞1级标题＜&#x2F;h6＞</li><li>特点：文字都加粗，且逐级减小，独占一行</li></ul><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><p>p</p><ul><li>＜p＞段落1＜&#x2F;p＞</li><li>＜p＞段落2＜&#x2F;p＞</li><li>特点：段落之间存在间隙，独占一行</li></ul><h3 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h3><p>br </p><ul><li>特点：单标签，让文字强制换行</li></ul><h3 id="水平分割线标签"><a href="#水平分割线标签" class="headerlink" title="水平分割线标签"></a>水平分割线标签</h3><p>hr</p><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><ul><li>加粗</li></ul><p>b或strong</p><ul><li>倾斜</li></ul><p>i或em</p><ul><li>下划线</li></ul><p>u或ins</p><ul><li>删除线</li></ul><p>s或del</p><h2 id="媒体标签"><a href="#媒体标签" class="headerlink" title="媒体标签"></a>媒体标签</h2><p>特点：单标签</p><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><p>img</p><ul><li>＜＞</li><li>＜img src&#x3D;”图片路径” alt&#x3D;” 替换文本” title&#x3D;”提示文本“ width&#x3D;”宽度” height&#x3D;”高度”＞<ul><li>替换文本：当图片不显示的时候显示的文字</li><li>提示文本：当鼠标悬停时显示的文本，title属性不仅仅可以用于图片标签，还可以用于其他标签</li><li>宽度和高度只给一个值时，另一个值会等比例缩放</li></ul></li><li>注意：属性之间以空格隔开，标签上可以同时存在多个属性，属性之间没有顺序之分</li></ul><h3 id="音频标签"><a href="#音频标签" class="headerlink" title="音频标签"></a>音频标签</h3><p>audio</p><ul><li>＜audio src&#x3D;”音频路径” controls autoplay loop＞<ul><li>controls：显示播放的控件</li><li>autoplay：自动播放（部分浏览器不支持）不建议使用</li><li>loop：循环播放，不建议使用</li></ul></li><li>注意：音频标签目前支持三个格式：mp3，wav，ogg</li></ul><h3 id="视频标签"><a href="#视频标签" class="headerlink" title="视频标签"></a>视频标签</h3><p>video</p><ul><li>＜video src&#x3D;”视频路径” controls autoplay loop＞<ul><li>controls：显示播放的控件</li><li>autoplay：自动播放（部分浏览器不支持）不建议使用</li><li>loop：循环播放，不建议使用</li></ul></li><li>注意：视频标签目前支持三个格式：mp4，webm，ogg</li></ul><h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><p>a</p><ul><li>＜a hred&#x3D;”跳转地址” target&#x3D;” _ blank “或 “_self”＞文本＜&#x2F;a＞<ul><li>_blank:跳转时保留原页面</li><li>_self:跳转时覆盖原页面</li></ul></li><li>特点：双标签，可以从一个页面跳转到另一个页面</li></ul><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>ul和li</p><ul><li>使用：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>特点：列表的每一项前默认显示圆点标识</li><li>注意：ul标签只能包含li标签，li标签可以包含任意内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>ol和li</p><ul><li>使用：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>特点：列表的每一项前默认显示序号标识</li><li>注意：ol标签只能包含li标签，li标签可以包含任意内容</li></ul><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>dl 和dt,dd</p><ul><li>使用：<ul><li>dl：用于包裹dt和dd标签</li><li>dt：表示自定义列表的主题</li><li>dd：表示自定义列表的对应主题的每一项内容</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>主题1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>主题1的内容1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>主题1的内容2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>主题1的内容3<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>特点：dd前会默认显示缩进效果</li><li>注意：dl标签只能包含dt和dd标签</li></ul><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><p>table、caption、tr、th和td</p><ul><li>使用：<ul><li>table：表格整体，用于包裹tr</li><li>caption：表格标题，写在table标签里</li><li>tr：表格每行，用于包裹th和td</li><li>th：表格单元格，包裹每一列的小标题</li><li>td：表格单元格，包裹内容</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;边框宽度&quot;</span> <span class="attr">width</span>=<span class="string">&quot;表格宽度&quot;</span> <span class="attr">height</span>=<span class="string">&quot;表格高度&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格名称<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意点：样式效果推荐使用css设置</li><li>可使用结构标签<strong>thead，tbody，tfoot</strong>让代码结构更明了</li><li>合并行用<strong>rowspan</strong>，合并列用<strong>colspan</strong></li></ul><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>input</p><ul><li><p>单标签</p></li><li><p>＜input type&#x3D;”属性值”＞</p></li><li><p>type属性值：</p><ul><li>text：文本框</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入手机号/邮箱&quot;</span>&gt;</span> //placeholder=&quot;后面跟提示文本&quot;</span><br></pre></td></tr></table></figure><ul><li>password：密码框</li><li>radio：单选框</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>&gt;</span>男 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女 //name=&quot;单选框的组别名&quot; checked(默认选中gai)</span><br></pre></td></tr></table></figure><ul><li>checkbox：多选框</li><li>file：上传文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span>//mutiple（多文件选择）</span><br></pre></td></tr></table></figure><ul><li>submit：提交按钮</li><li>reset：重置按钮</li></ul></li><li><p>注意：要想reset按钮生效，需要将想要重置的内容让＜form action&#x3D;” “＞ …＜&#x2F;form＞包裹住</p><ul><li>button：普通按钮，默认无功能，之后配合js添加功能</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登入&quot;</span>&gt;</span> value=&quot;按钮名&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="button标签"><a href="#button标签" class="headerlink" title="button标签"></a>button标签</h3><p>button</p><ul><li><p>双标签</p></li><li><p>＜button type&#x3D;“属性值”＞按钮名＜button＞</p></li><li><p>type属性值：</p><ul><li>submit：提交按钮</li><li>reset：重置按钮</li><li>button：普通按钮，默认无功能，之后配合js添加功能</li></ul></li></ul><h3 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h3><p>select</p><ul><li><p>功能：下拉菜单</p></li><li><p>使用：</p><ul><li>selelct标签：下拉菜单整体</li><li>option标签：下拉菜单每一项</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span>//selected：默认选中</span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="textarea标签"><a href="#textarea标签" class="headerlink" title="textarea标签"></a>textarea标签</h3><p>textarea</p><ul><li>功能：多行输入的文本域</li><li>＜textarea cols&#x3D;“可见列数” rows&#x3D;”可见行数“＞＜&#x2F;textarea＞</li><li>注意：可拖拽大小，对于样式效果推荐使用css设置</li></ul><h3 id="lable标签"><a href="#lable标签" class="headerlink" title="lable标签"></a>lable标签</h3><p>label</p><ul><li>功能：常用于绑定内容与表单内容的关系</li><li>＜label＞内容与表单内容内容与表单内容 ＜&#x2F;label＞</li></ul><h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><h3 id="无语言化"><a href="#无语言化" class="headerlink" title="无语言化"></a>无语言化</h3><p>div</p><ul><li>＜div＞…＜&#x2F;div＞</li><li>独占一行</li></ul><p>span</p><ul><li>＜span＞…＜&#x2F;span＞</li><li>不会换行</li></ul><h3 id="有语义化"><a href="#有语义化" class="headerlink" title="有语义化"></a>有语义化</h3><ul><li>独占一行</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>网页头部<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>网页导航<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>网页区块<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>＆nbsp；：表示空格</p><h1 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h1><p>Css概述</p><ul><li>css的引入方式<ul><li>内嵌式：css写在style标签中，style标签写在head标签内，title标签下。作用范围(当前页面)，使用场景(小案例中)</li><li>外联式：css单独写在css文件中，在html文件中通过link标签引入l，ink标签写在head标签内，title标签下。作用范围(多个页面)，使用场景(项目中)</li><li>行内饰：css写在标签的sytle属性中。作用范围(当前标签)，使用场景(配合js使用)</li></ul></li></ul><h2 id="Css书写顺序"><a href="#Css书写顺序" class="headerlink" title="Css书写顺序"></a>Css书写顺序</h2><ol><li>浮动  &#x2F; display</li><li>盒子模型</li><li>文字样式</li></ol><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器的作用：查找标签</p><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><ul><li>结构：标签名{css属性名：属性值:}</li><li>作用：通过标签名，找到页面中所有这类标签，设置样式</li></ul><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><ul><li>结构：.类名{css属性名：属性值:}</li><li>作用：通过类名，找到页面中所有带有这个类名的标签，设置样式</li><li>注意：<ul><li>所有标签上都有class属性,class属性的属性值称为类名(类似于名字)</li><li>类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头</li><li>一个标签可以同时有多个类名，类名之间以空格隔开</li></ul></li></ul><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><ul><li>结构：#id属性值{css属性名：属性值:}</li><li>作用：通过id属性值，找到页面中带有这个id属性值的标签，设置样式</li><li>注意：<ul><li>所有标签上都有id属性</li><li>id属性值类似于身份证号码，在一个页面中是唯一的，不可重复的!</li><li>一个标签上只能有一个id属性值</li><li>一个id选择器只能选中一个标签</li></ul></li></ul><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><ul><li>结构：*{css属性名：属性值:}</li><li>作用：找到页面中所有的标签，设置样式</li><li>注意：<ul><li>开发中使用极少，只会在极特殊情况下才会用到</li><li>可能会用于去除标签默认的margin和padding</li></ul></li></ul><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><ul><li>作用：根据HTML标签的嵌套关系，选择父元素<strong>后代</strong>中满足条件的元素</li><li>结构：选择器1 选择器2 {css}</li><li>注意：<ul><li>后代包括:儿子、孙子、重孙子…….</li><li>后代选择器中，选择器与选择器之前通过<strong>空格</strong>隔开</li></ul></li></ul><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><ul><li>作用：根据HTML标签的嵌套关系，选择父元素<strong>子代</strong>中满足条件的元素</li><li>结构：选择器1＞选择器2{css}</li><li>注意：<ul><li>子代只包括:儿子</li><li>子代选择器中，选择器与选择器之前通过**&gt;**隔开</li></ul></li></ul><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><ul><li>作用：同时选择多组标签，设置相同的样式</li><li>结构：选择器1，选择器2{css}</li><li>注意：<ul><li>并集选择器中的每组选择器之间通过<strong>，</strong>分隔</li></ul></li></ul><h3 id="交急选择器"><a href="#交急选择器" class="headerlink" title="交急选择器"></a>交急选择器</h3><ul><li>作用：选中页面中同时满足多个选择器的标签</li><li>结构：选择器1选择器2 {css}</li><li>注意： <ul><li>交集选择器中的选择器之间是紧挨着的，没有东西分隔</li><li>交集选择器中如果有标签选择器，标签选择器必须写在最前面</li></ul></li></ul><h3 id="hover伪类选择器"><a href="#hover伪类选择器" class="headerlink" title="hover伪类选择器"></a>hover伪类选择器</h3><ul><li>作用：选中鼠标悬停在元素上的状态，设置样式</li><li>结构：E：hover{css}</li><li>注意：伪类选择器选中的元素的某种状态</li></ul><h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><ul><li>作用：根据元素在HTML中的结构关系查找元素，减少对于HTML中类的依赖，有利于保持代码整洁常用于查找某父级选择器中的子元素</li><li>选择器<ul><li>E:first-child{}：匹配父元素中第一个子元素</li><li>E:last-child {}：匹配父元素中最后一个子元素</li><li>E:nth-child(n) {}：匹配父元素中第n个子元素</li><li>E: nth-last-chi1d(n){}：匹配父元素中倒数第n个子元素</li><li>注意:()里面除了写n还可以写公式（如：2n、2n-1）</li></ul></li></ul><h3 id="focus伪类选择器"><a href="#focus伪类选择器" class="headerlink" title="focus伪类选择器"></a>focus伪类选择器</h3><ul><li>获得焦点</li><li>E：focus{css}</li></ul><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p>字体大小</p><ul><li>属性名：font-size<ul><li>取值：数字+px</li><li>默认大小：16px</li></ul></li></ul><p>字体粗细:</p><ul><li>属性名：font-weight<ul><li>取值<ul><li>关键字法：normal(正常)，bold(加粗) </li><li>纯数字法：100~900（正常是400，加粗是700）</li></ul></li></ul></li></ul><p>字体样式(倾斜)</p><ul><li>属性名：font-style<ul><li>取值：normal(正常)，italic(倾斜)</li></ul></li></ul><p>字体类型</p><ul><li>属性名：font-family<ul><li>取值：黑体、宋体、楷体、微软雅黑(默认)….</li></ul></li></ul><p>字体复合属性</p><ul><li>属性名：font<ul><li>取值：font：style weight size&#x2F;line-height family；</li><li>注意：只能省略前两个，如果省略了相当于设置了默认值</li></ul></li></ul><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><p>文本缩进</p><ul><li>属性名：text-indent</li><li>取值：数字+px 或 数字+em(推荐：1em&#x3D;当前标签的font-size的大小)</li></ul><p>对齐方式</p><ul><li>属性名：text-align</li><li>取值：left、center、right</li></ul><p>文本修饰线</p><ul><li>属性名：text-decoration</li><li>取值：underline(下划线)、line-through(删除线)、overline(上划线)、none(无修饰)</li></ul><p>行高</p><ul><li>属性名：line-height</li><li>取值：数字+px、倍数(当前标签font-size的倍数 )</li><li>行高由上部分高度、文字高度、下部分高度组成</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>背景颜色</p><ul><li>background-color：颜色</li></ul><p>背景图片</p><ul><li>background-image：url(‘图片路径’)</li></ul><p>背景图片大小</p><ul><li><p>background-size：宽度 高度</p></li><li><p>取值</p><table><thead><tr><th>取值</th><th>场景</th></tr></thead><tbody><tr><td>数字+px</td><td>简单方便，常用</td></tr><tr><td>百分比</td><td>相对于当前盒子自身的宽高百分比</td></tr><tr><td>contain</td><td>包含，将背景图片等比例缩放，直到不会超出盒子的最大</td></tr><tr><td>cover</td><td>覆盖，将背景图片等比例缩放，直到刚好填满整个盒子没有空白</td></tr></tbody></table></li></ul><p>背景平铺</p><ul><li>属性名：background-repeat</li><li>属性值：<ul><li>repeat：默认值，水平和垂直方向都平铺</li><li>no-repeat：不平铺</li><li>repeat-x：沿着水平方向平铺</li><li>repeat-y：沿着垂直方向平铺</li></ul></li></ul><p>背景位置</p><ul><li>属性名：background-position</li><li>属性值：background-position：水平方向位置 垂直方向位置<ul><li>取法一：方位名词<ul><li>水平：left、center、right</li><li>垂直：top、center、bottom</li></ul></li><li>取法二：坐标法，数字+px（原点是左上角）<ul><li>x轴：水平向右</li><li>y轴：垂直向下</li></ul></li></ul></li></ul><p>背景复合连写</p><ul><li>属性名：background</li><li>属性值：单个属性值的合写，取值之间以逗号隔开</li><li>推荐书写顺序：background：color image repeat position</li></ul><h2 id="显示模式"><a href="#显示模式" class="headerlink" title="显示模式"></a>显示模式</h2><p>块</p><ul><li>特点：<ul><li>独占一行</li><li>宽度默认为父元素的宽度，高度默认由内容撑开</li><li>可以设置宽高</li></ul></li><li>代表标签：div,p,h,ul,li,dl,dt,dd,form,header,nav,footer…</li></ul><p>行内</p><ul><li>特点：<ul><li>一行可以显示多个</li><li>宽度和高度默认由内容撑开</li><li>不可以设置宽高</li></ul></li><li>代表标签：a、span、b、u、i、s、strong、ins、em、del…</li></ul><p>行内块</p><ul><li><p>特点：</p><ul><li>一行可以显示多个</li><li>可以设置宽高</li></ul></li><li><p>代表标签：input、textarea、button、select、img</p></li></ul><p>显示模式的转换</p><ul><li>display：block（转换成块）</li><li>display：inline-block（转换成行内块）</li><li>display：inline（转换成行内）</li></ul><p>嵌套规范</p><ul><li>块一般作为大容器，可以嵌套：文本，块，行内，行内块… </li><li>p标签不能嵌套div，p，h等块级标签</li><li>a标签不能嵌套a标签</li></ul><h2 id="css特性"><a href="#css特性" class="headerlink" title="css特性"></a>css特性</h2><p>继承性</p><ul><li><p>子元素有默认继承父元素的特点</p></li><li><p>可以继承的常见属性（文字控制属性都可以继承）：color、font、text-indemt、text-align、line-height…</p></li><li><p>a标签的color和h标签的font-size会继承失效</p></li></ul><p>层叠性</p><ul><li>给同一个标签设置不同的样式→此时样式会层叠叠加→会共同作用在标签上</li><li>给同一个标签设置相同的样式→此时样式会层叠覆盖→最终写在最后的样式会生效</li></ul><p>优先级</p><ul><li>特性：不同选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低选择器样式</li><li>优先级：继承&lt;通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;!important</li><li>注意：<ul><li>!important写在属性值的后面，分号的前面</li><li>!important不能提升继承的优先级，只要是继承优先级最低!</li><li>实际开发中不建议使用!important</li></ul></li><li>权重叠加：行内样式个数，id选择器个数，类选择器个数，标签选择器个数</li></ul><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>页面中的每一个标签，都可看做是一个“盒子”</li><li>浏览器在渲染（显示)网页时，会将网页中的元素看做是一个个的矩形区域，我们也形象的.<br>之为盒子</li><li>CSS 中规定每个盒子分别由∶内容区域(content)、内边距区域(padding)、边框区域(border)、外边距区域（margin)构成，这就是盒子模型</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>盒子的布局思路：从外到内：先宽高背景色—内容—内容位置</p></li><li><p>盒子的实际宽度&#x3D;height+盒子内边距的左右+边框左右边的粗细</p></li><li><p>盒子的实际高度&#x3D;wight+盒子内边距的上下+边框上下边的粗细</p></li><li><p>在css3之后可以给盒子加上自动内减属性：box-sizing：border-box（这样盒子就不会被border和padding撑大了）</p></li><li><p>版心居中：margin：0 auto；</p></li><li><p>清楚标签内外间距默认样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>：<span class="number">0</span></span><br><span class="line">    pading：<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>行内标签</strong>的内外间距的垂直位置无法改变（解决方案：加行高 或 将行内改成块）</p></li></ul><h3 id="内容的宽高"><a href="#内容的宽高" class="headerlink" title="内容的宽高"></a>内容的宽高</h3><ul><li>作用：利用width和 height属性默认设置是盒子<strong>内容区域</strong>的大小</li><li>属性名：width &#x2F; height</li><li>取值：数字+px</li></ul><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul><li>属性名：border</li><li>取值：边框粗细 边框类型 边框颜色<ul><li>边框类型：solid、dashed、dotted…</li></ul></li><li>快捷键：bd+tab（1px solid 黑色#000）</li><li>单方向设置边框：border-方位名词（top、bottom、left、right）</li><li>border-collapse属性<ul><li>collapse：边框会合并为一个单一的边框</li><li>separate：默认值。边框会被分开</li></ul></li></ul><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><ul><li>属性名：padding</li><li>取值：数字+px（顺序为上右下左）</li></ul><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><ul><li>属性名：margin</li><li>取值：数字+px（顺序为上右下左）</li><li>常见问题：<ul><li><p>合并：</p><ul><li>垂直垂直布局的块级元素，上下的margin会合并，最终两者距离为margin的最大值</li><li>解决方案：</li></ul></li><li><p>塌陷：</p><ul><li>互相嵌套的块级元素，子元素的margin-top会作用在父元素上，导致父元素一起往下移动</li><li>解决方案：给父元素设置overflow：hidden、子元素换成行内块元素、设置浮动</li></ul></li></ul></li></ul><h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><ul><li><p>属性名：box-shadow</p></li><li><p>取值</p><table><thead><tr><th>参数</th><th>效果</th></tr></thead><tbody><tr><td>h-shadow</td><td>必须，水平偏移量。允许负值</td></tr><tr><td>v-shadow</td><td>必须，垂直偏移量。允许负值</td></tr><tr><td>blur</td><td>可选,，模糊度</td></tr><tr><td>spread</td><td>可选，阴影扩大</td></tr><tr><td>color</td><td>可选，阴影颜色</td></tr><tr><td>inset</td><td>可选，将阴影改为内部阴影</td></tr></tbody></table></li></ul><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><ul><li>作用：通过css创建标签，装饰一些不重要的小图</li><li>种类<ul><li>E::before(在父元素内容的最前添加一个伪元素)</li><li>E::after(在父元素内容的最后添加一个伪元素)</li></ul></li><li>注意：必须设置content属性才能生效，伪元素默认是行内元素</li></ul><h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><ul><li>标准流：又称文档流，是浏览器在渲染显示网页内容时默认采用的一套排版规则</li><li>常见规则<ul><li>块级元素:从上往下，垂直布局，独占一行</li><li>行内元素或行内块元素:从左往右，水平布局，空间不够自动折行</li></ul></li></ul><h3 id="浮动-1"><a href="#浮动-1" class="headerlink" title="浮动"></a>浮动</h3><ul><li><p>属性名：float</p></li><li><p>作用：图文环绕、网页布局</p></li><li><p>特点：</p><ul><li>浮动元素会脱离标准流(简称:脱标)，在标准流中不占位置（相当于从地面飘到了空中）</li><li>浮动元素比标准流高半个级别，可以覆盖标准流中的元素</li><li>浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动</li><li>浮动后的标签具备行内块特点</li></ul></li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li><p>作用：清除浮动带来的影响</p><ul><li>影响：如果子元素浮动了，此时子元素不能撑开标准流的块级父元素</li><li>影响产生的原因：父子级标签，子级浮动,父级没有高度，后面的标准流盒子会受影响，显示到上面的位置</li></ul></li><li><p>清除方法：</p></li></ul><ol><li><p>设置父元素高度</p></li><li><p>额外标签法：在父元素内容的最后添加一个块级元素，给该块级元素设置clear：both</p></li><li><p>单伪元素清除法：原理和方法2一样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    conten=&#x27;&#x27;;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="comment">/*以下为补充代码：在网页中看不到该伪元素，可加可不加*/</span></span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双伪元素去除法</p></li><li><p>overflow法：给父元素添加overflow：hidden（最常用）</p></li></ol><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul><li>定位：可以让元素自由的摆放在网页的任意位置，一般用于盒子之间的层叠情况</li><li>注意：如果left和right都有，以left为准; top和bottom都有以top</li><li>子绝父相：父级相对定位，子级绝对定位</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>设置定位方式<ul><li>属性名：position</li><li>常见属性值：static(静态定位)、relative(相对定位)、absolute(绝对定位)、fixed(固定定位)</li></ul></li><li>设置偏移值<ul><li>属性名：left、right、top、bottom</li><li>属性值：数字+px</li></ul></li></ol><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><ul><li><p>相对定位：参照自己原来的位置来改变位置</p></li><li><p>属性值：relative</p></li><li><p>特点：</p><ul><li>占有原来的位置</li><li>仍然具体标签原有的显示模式特点</li></ul></li><li><p>应用场景：</p><ul><li>用于小范围的移动</li></ul></li></ul><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><ul><li>绝对定位：<ul><li>先找已经定位的父级，如果有这样的父级就以这个父级为参照物进行定位。</li><li>有父级，但父级没有定位，以浏览器窗口为参照为进行定位</li><li>绝对定位查找父级的方式：就近找定位的父级，如果逐层查找不到这样的父级，就以浏览器窗口为参照进行定位</li></ul></li><li>属性值：absolute</li><li>特点：<ul><li>脱标,不占位</li><li>改变标签的显示模式特点:具体<strong>行内块</strong>特点</li></ul></li><li>注意：绝对定位的盒子不能使用左右margin auto居中<ol><li>先用 left: 50%，将整个盒子移动到浏览器中间偏右的位置，再用margin-left：盒子宽度一半的px，把盒子向左侧移动:自己宽度的一半（top同理）</li><li>transform：translate(-50%,-50%)再加上left：50%和top：50%</li></ol></li></ul><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><ul><li>属性值：fixed</li><li>特点：<ul><li>脱标-不占位置</li><li>改变位置参考浏览器窗口</li><li>具备行内块特点</li></ul></li></ul><h3 id="元素的层级"><a href="#元素的层级" class="headerlink" title="元素的层级"></a>元素的层级</h3><ul><li>不同布局方式元素的层级关系：<ul><li>标准流＜浮动＜定位</li></ul></li><li>不同定位之间的层级关系：<ul><li>相对、绝对、固定默认层级相同。</li><li>此时HTML中写在下面的元素层级更高，会覆盖上面的元素</li><li>默认情况下,定位的盒子后来者居上</li><li>z-index:整数;取值越大,显示顺序越靠上</li></ul></li></ul><h2 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h2><h3 id="垂直对齐方式"><a href="#垂直对齐方式" class="headerlink" title="垂直对齐方式"></a>垂直对齐方式</h3><ul><li><p>问题：</p><ul><li>浏览器遇到<strong>行内和行内块</strong>标签当做文字处理,默认文字是按基线对象</li><li>基线:浏览器文字类型元素排版中存在用于对齐的基线</li></ul></li><li><p>属性名：vertical-align</p></li><li><p>属性值</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>baseline</td><td>默认，基线对齐</td></tr><tr><td>top</td><td>顶部对齐</td></tr><tr><td>middle</td><td>中部对齐</td></tr><tr><td>bottom</td><td>底部对齐</td></tr></tbody></table></li></ul><h3 id="光标类型"><a href="#光标类型" class="headerlink" title="光标类型"></a>光标类型</h3><ul><li><p>属性名：cursor</p></li><li><p>属性值</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>default</td><td>默认值，通常是箭头</td></tr><tr><td>pointer</td><td>小手效果，提示用户可以点击</td></tr><tr><td>text</td><td>工字型，提示用户可以选择文字</td></tr><tr><td>move</td><td>十字光标，提示用户可以移动</td></tr></tbody></table></li></ul><h3 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h3><ul><li>场景：让盒子四个角变得圆润，增加页面细节，提升用户体验</li><li>属性名：border-radius</li><li>属性值：数字+px、百分比<ul><li>正圆：border-radius：50%</li><li>胶囊：border-radius：盒子高度的一半px</li></ul></li><li>赋值规则：从左上角开始赋值，然后顺时针赋值，没有赋值的看对角!，一个值:表示4个角是相同的。</li></ul><h3 id="溢出显示"><a href="#溢出显示" class="headerlink" title="溢出显示"></a>溢出显示</h3><ul><li><p>溢出部分:指的是盒子内容部分所超出盒子范围的区域</p></li><li><p>属性名：overflow</p></li><li><p>属性值</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>visble</td><td>默认值，溢出部分可见</td></tr><tr><td>hidden</td><td>溢出部分隐藏</td></tr><tr><td>scroll</td><td>无论是否溢出，都显示滚动条</td></tr><tr><td>auto</td><td>根据是否溢出，自动显示或隐藏滚动条</td></tr></tbody></table></li></ul><h3 id="显示隐藏"><a href="#显示隐藏" class="headerlink" title="显示隐藏"></a>显示隐藏</h3><ul><li>场景：让某元素本身在屏幕中不可见。如:鼠标:hover之后元素隐藏</li><li>常见属性<ul><li>visibility: hidden  （占位隐藏）</li><li>display: none  （不占位隐藏）</li></ul></li></ul><h3 id="透明"><a href="#透明" class="headerlink" title="透明"></a>透明</h3><ul><li>场景:让某元素整体（包括内容)一起变透明</li><li>属性名：opacity</li><li>属性值：0-1之间的数字，1表示不透明，0表示完全透明</li><li>注意：opacity会让元素整体透明，包括里面的内容，如:文字、子元素等…….</li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="标题图标"><a href="#标题图标" class="headerlink" title="标题图标"></a>标题图标</h3><ul><li>习惯使用.ico格式的图标</li><li>代码：＜link rel&#x3D;”shortcut icon” herf&#x3D;”ico图标路径” type&#x3D;”image&#x2F;x-icon”＞快捷打法：link：favicon</li></ul><h3 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h3><ul><li>场景：项目中将多张小图片，合并成一张大图片，这张大图片称之为精灵图</li><li>优点：减少服务器发送次数，减轻服务器的压力，提高页面加载速度</li><li>使用步骤：<ol><li>创建一个盒子,设置盒子的尺寸和小图尺寸相同</li><li>将精灵图设置为盒子的背景图片</li><li>修改背景图位置 （background-position:x y）</li></ol></li></ul><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><ul><li>作用:让元素的样式慢慢的变化,常配合hover使用，增强网页交互体验</li><li>属性名：transition</li><li>常见取值<ul><li>过渡的属性：可以写具体的属性名，也可以直接写all</li><li>过渡的时长：数字+s</li></ul></li></ul><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><ul><li>SEO (Search Engine Optimization) :搜索引擎优化</li><li>作用:让网站在搜索引擎上的排名靠前</li><li>seo三大标签：title、description、keywords</li></ul><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><ul><li>transparent属性：类似rgba(0,0,0,0)这样的透明色</li></ul><h3 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h3><ul><li>语法：display:flex</li><li>作用：和浮动一样都用于网页布局，但flex比浮动要更强大。flex不会产生脱标现象，布局网页更灵活、更简单 </li><li>组成：弹性容器+弹性盒子+主轴+侧轴</li><li>效果<ul><li>盒子沿主轴方向排列（主轴方向可以改变，主轴在哪个方向盒子就沿哪个方向排列）</li><li>盒子自动挤压（盒子自动缩小适应父元素大小让所有子元素在一行显示）</li><li>盒子自动拉伸（若父元素没有设置高度，那么子元素会自动拉伸高度适应父元素）</li></ul></li><li>主轴对齐方式 <ul><li>语法：justify-content：对齐方式</li><li>center：弹性盒子沿主轴居中排列</li><li>space-between：弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子之间</li><li>space-around：弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧</li><li>space-evenly：弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等</li><li>flex-start：默认值，弹性盒子从起点开始依次排列</li><li>flex-end：弹性盒子从终点开始依次排列</li></ul></li></ul><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul><li>JavaScript是什么？</li></ul><p>JavaScript是一种运行在客户端（浏览器)的编程语言</p><ul><li>JavaScript的组成有哪些？</li></ul><p>ECMAScript(基础语法)、web APIs ( DOM、BOM)</p><h3 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h3><h4 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h4><ul><li>写在html文件里，用script标签包住</li><li>规范：script标签写在＜&#x2F;body＞上面<ul><li>原因：我们将＜srcipt＞放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载HTML。如果先加载的JavaScript期望修改其下方的HTML，那么它可能由于HTML尚未被加载而失效。因此，将JavaScript 代码放在HTML页面的底部附近通常是最好的策略。</li></ul></li></ul><h4 id="外部"><a href="#外部" class="headerlink" title="外部"></a>外部</h4><ul><li>代码写在以.js结尾的文件里</li><li>语法：通过script标签（用src），引入到html页面中。</li><li>注意：外部写法script标签中间不要写代码，否则会被忽略</li></ul><h4 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h4><ul><li>代码写在标签内部</li></ul><h3 id="注释和修饰符"><a href="#注释和修饰符" class="headerlink" title="注释和修饰符"></a>注释和修饰符</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>单行注释：&#x2F;&#x2F;</li></ul><p>快捷键：ctrl+&#x2F;</p><ul><li>多行注释：&#x2F;* *&#x2F;</li></ul><p>快捷键：shift+ctrl+&#x2F;</p><h4 id="结束符"><a href="#结束符" class="headerlink" title="结束符"></a>结束符</h4><ul><li>作用:使用英文的;代表语句结束</li><li>实际情况:实际开发中，可写可不写，浏览器(JavaScript 引擎)可以自动推断语句的结束位置</li></ul><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>alert()和prompt()它们会跳过页面渲染先被执行</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul><li>语法：prompt(‘要输入的内容’)</li><li>注意：prompt接收的内容默认为字符串型</li><li>作用:显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字</li></ul><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>语法1</p><ul><li>document.write(‘要输出的内容’)</li><li>作用:向body内输出内容</li><li>注意:如果输出的内容写的是标签，也会被解析成网页元素</li></ul><p>语法2</p><ul><li>alert(‘要输出的内容’)</li><li>作用:页面弹出警告对话框</li></ul><p>语法3</p><ul><li>conso.log(’控制台打印内容‘)</li><li>作用:控制台输出语法，程序员调试使用</li></ul><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>语法：let 变量名 &#x3D; 值</li><li>注意：旧版本中变量的声明用的并不是let，而是var</li></ul><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul><li>字母严格区分大小写</li><li>不能用关键字</li><li>只能用下划线、字母、数字、$组成，且数字不能开头</li><li>起名要有意义，遵守小驼峰命名法</li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul><li>在开发中，变量的声明优先用const，尤其是数组和对象的声明</li><li>语法：const 常量名 &#x3D; 值</li><li>注意：<ul><li>常量不允许重新赋值,且声明的时候必须赋值，常量名通常全大写</li></ul></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>typeof：可以检测数据类型</p><p>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。</p><ul><li>值类型:简单数据类型&#x2F;基本数据类型，在存储时变量中存储的是<strong>值本身</strong>，因此叫做值类型</li><li>引用类型:复杂数据类型，在存储时变量中存储的仅仅是<strong>地址</strong>（引用），因此叫做引用数据类型</li></ul><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>number数字型</p><p>string字符串型</p><ul><li>单引号(‘ ‘)、双引号(“ “)、反引号(&#96;&#96;)</li><li>字符串拼接用+号</li><li>模板字符串：外面用反引号，里面用￥{变量名}</li></ul><p>boolean布尔型</p><ul><li>0、undefined、null、false、NaN转换为布尔值后都是false,其余则为true</li></ul><p>undefined未定义型</p><p>null空类型</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>Object对象</p><p>Array数组</p><p>Date</p><p>等通过new关键字创建的对象</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><ul><li>＋号两边只要有一个是字符串，都会把另外一个转成字符串</li><li>除了+以外的算术运算符比如– *&#x2F;等都会把数据转成数字类型</li><li>+号作为正号解析可以转换成数字型</li></ul><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><ul><li>Number（数据）</li><li>+数据</li><li>parseInt（数据）：只保留整数</li><li>parseFloat（数据）：可以保留小数</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><ul><li>&#x3D;&#x3D;&#x3D;：全等比较（值和类型都比，开发中判断是否相等一般都是用这个）</li><li>！&#x3D;&#x3D;：左右两边是否不全等</li><li>注意：<ul><li>NaN不等于任何东西，包括他自己</li><li>尽量不要比较小数，因为小数有精度问题</li><li>不同类型之间比较会发生隐式转换</li></ul></li></ul><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)&#123;</span><br><span class="line">    满足条件<span class="number">1</span>执行的代码</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>)&#123;</span><br><span class="line">    满足条件<span class="number">2</span>执行的代码</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    不满足条件执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件 ? 满足条件执行的代码 :不满足条件执行的代码</span><br></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(数据)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        代码<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>：</span><br><span class="line">        代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        代码n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>break：退出循环</p><p>continue：结束本次循环</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量起始值;终止条件;变量变化值)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><ul><li>语法1：let 数组名 &#x3D; [数据1，数据2，数据3…]</li><li>语法2：let 数组名 &#x3D; new Array(数据1，数据2，数据3…)</li></ul><h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><p>增</p><ul><li><p>arr.push(新增内容)：将一个或多个元素添加到数组的末尾，并返回该数组的新长度</p></li><li><p>arr.unshift(新增内容)：将一个或多个元素添加到数组的开头，并返回该数组的新长度</p></li></ul><p>删</p><ul><li>arr.pop()：删除最后一个元素，并返回</li><li>arr.shift()：删除第一个元素，并返回</li><li>arr.splice(起始操作的下标，删除的个数)</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>sort：默认是升序</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(形参)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">形参</span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名函数的可以用 函数表达式的方式调用：let 变量名 &#x3D; function(){}</li></ul><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">法一：(<span class="keyword">function</span>(<span class="params">形参</span>)&#123;&#125;)(实参);</span><br><span class="line">法二；(<span class="keyword">function</span>(<span class="params">形参</span>)&#123;&#125;(实参));</span><br></pre></td></tr></table></figure><ul><li>使用立即执行函数一定要在结尾+；</li></ul><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li>length()：返回长度</li><li>trim()：去除字符串两边空格</li><li>substring()：提取字符串中两个指定索引之间的字符</li><li>chatAt()：获取指定索引位置的字符</li><li>indexOf()：检索某个字符串的位置</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">法一：<span class="keyword">let</span> 对象名 = &#123;</span><br><span class="line">    属性名<span class="number">1</span>:属性值<span class="number">1</span>，</span><br><span class="line">    属性名<span class="number">2</span>:属性值<span class="number">2</span>，</span><br><span class="line">    方法名<span class="number">1</span>:函数<span class="number">1</span>，</span><br><span class="line">    方法名<span class="number">2</span>:函数<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">法二：<span class="keyword">let</span> 对象名 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure><ul><li>每组属性或方法之间用逗号隔开</li></ul><h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h4><p>属性</p><ul><li>增：对象名.新属性值&#x3D;新值</li><li>删：delete 对象名.属性</li><li>改：对象名.属性名&#x3D;新值</li><li>查：<ul><li>法一：对象名.属性名</li><li>法二：对象名[‘属性名’]</li></ul></li></ul><p>方法</p><ul><li>对象名.方法名()</li></ul><h4 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> 对象名)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(对象名[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：k得到的是<strong>字符串型</strong>的属性名</li></ul><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>Math</p><ul><li>ceil：向上取整</li><li>floor：向下取整</li><li>round：四舍五入</li><li>max：取最大值</li><li>min：取最小值</li><li>abs：取绝对值</li><li>random：返回0-1之间的一个数（左闭右开）<ul><li>生成0-10之间的一个随机整数：Math.floor(Math.random()*11)</li><li>生成N-M之间的一个随机整数：Math.floor(Math.random()*(M-N+1))+N</li></ul></li></ul><h4 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h4><ul><li>环境对象：this它代表着当前函数运行时所处的环境，是函数内部特殊的</li><li>this指向的是调用者</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul><li>JavaScript Object Notation, JavaScript对象标记法。</li><li>多用于作为数据载体，在网络中进行数据传输。</li><li>格式：’{“key1”:value1,”key2”:value2} ‘</li><li>json字符串转为js对象：JSON .parse(json字符串)</li><li>js对象转为json字符串：JSON .stringify(js对象)</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;jy&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">22</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;male&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ul><li>作用：就是使用JS去操作html和浏览器</li><li>分类：DOM(文档对象模型)、BOM（浏览器对象模型)</li></ul><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM：操作网页内容，开发网页内容特效和实现用户交互</p><p>DOM对象：浏览器根据html标签生成的JS<strong>对象</strong>，DOM的核心就是把内容当对象来处理</p><h4 id="获取DOM"><a href="#获取DOM" class="headerlink" title="获取DOM"></a>获取DOM</h4><ul><li>语法：document.querySelector(‘css选择器’)<ul><li>返回值：获取匹配的第一个元素对象</li></ul></li><li>语法：document.querySelectorAll(‘css选择器’)<ul><li>返回值：CSS选择器匹配的NodeList 对象集合，该集合是一个伪数组，有长度和索引号，但没有pop、push等方法</li></ul></li></ul><h4 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h4><p>内容</p><ul><li>语法：对象.innerText &#x3D;’内容’<ul><li>不会解析标签</li></ul></li><li>语法：对象.innerHTML&#x3D;’内容’<ul><li>会解析标签</li></ul></li></ul><p>属性</p><ul><li>语法：对象.属性&#x3D;‘值’</li></ul><p>样式</p><ul><li>语法：对象.style.样式属性&#x3D;’值’<ul><li>对于有连接符-的样式属性，如background-color，不能直接写，可以采用小驼峰命名的方式写成backgroundColor</li></ul></li><li>语法：对象.className&#x3D;’css的某个类名’<ul><li>如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。</li></ul></li><li>语法：对象.<strong>classList</strong>.要执行的方法(‘css的某个类名’)<ul><li>add方法：追加一个类</li><li>remove方法：删除一个类</li><li>toggle方法：切换一个类</li></ul></li></ul><p> 表单属性</p><ul><li>语法：对象.属性&#x3D;’值‘</li></ul><p>自定义属性</p><ul><li>在标签上加data-xxx&#x3D;”自定义属性值”</li><li>获取方式：对象.dataset.xxx</li></ul><h4 id="间歇函数"><a href="#间歇函数" class="headerlink" title="间歇函数"></a>间歇函数</h4><ul><li>setInterval(函数名，间隔时间)<ul><li>每隔一段时间调用这个函数，间隔时间的单位是毫秒，函数名不需要加括号，返回值是一个数字</li><li>关闭：clearInterval（变量名）</li></ul></li></ul><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>老版本</p><ul><li><p>语法：元素对象.on事件类型&#x3D;(要执行的方法)</p></li><li><p>都是冒泡阶段执行的</p></li><li><p>事件解绑语法：元素对象.on事件类型&#x3D;null</p></li></ul><p>新版本</p><ul><li>语法：元素对象.addEventListener(‘事件类型’,要执行的函数)</li><li>事件源：元素对象</li><li>事件类型：如鼠标点击，键盘敲击等<ul><li>鼠标事件<ul><li>click:鼠标点击</li><li>mouseenter:鼠标经过</li><li>mouseleave:鼠标离开</li></ul></li><li>键盘事件<ul><li>keydown:键盘按下</li><li>keyup:键盘离开</li></ul></li><li>焦点事件<ul><li>focus:获得焦点</li><li>blur:失去焦点</li></ul></li><li>文本事件<ul><li>input:用户输入</li></ul></li><li>页面加载事件<ul><li>load：监听整个页面资源(给window加)</li><li>DOMContentLoaded：无需等待样式表、图像等完全加载（给document加）</li></ul></li><li>页面滚动事件<ul><li>scroll</li><li>获取滚动距离的属性：scrollTop，scrollLeft(document.documentElement.属性)</li></ul></li></ul></li><li>事件解绑：元素对象.removeEventListener(‘事件类型’,函数名)</li><li>事件对象<ul><li>在事件绑定的执行函数中的第一个参数就是事件对象，通常用e，ev，event来表示</li></ul></li></ul><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><ul><li>事件流：指的是事件完整执行过程中的流动路径</li><li>事件捕获：从DOM的根元素开始去执行对应的事件（从外到里)</li><li>事件冒泡：当一个元素触发事件后，会依次向上调用所有父级元素的同名</li><li>阻止事件流<ul><li>语法：事件对象.stopPropagation()</li></ul></li><li>事件委托<ul><li>事件委托委托给的是父元素</li><li>减少注册次数，提高了程序性能</li><li>如何找到真正触发的子元素：事件对象.target.tagName</li></ul></li></ul><h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><p>阻止元素默认行为</p><ul><li>语法：事件对象.preventDefault()</li></ul><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><ul><li>xxx-pc-client（项目目录）<ul><li>index.html （首页的html文件）</li><li>favicon.ico（ico图标）</li><li>images（固定使用的图片素材文件）</li><li>uploads（非固定使用的图片素材文件）</li><li>css（css文件）<ul><li>base.css（基础公共样式）</li><li>common.css（多个网页相同模块的重复样式）</li><li>index.css（首页的css）</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端三大件 HTML CSS JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2024/04/29/Java%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/29/Java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p>单行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是单行注释</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个</span></span><br><span class="line"><span class="comment">多行注释*/</span></span><br></pre></td></tr></table></figure></li><li><p>文档注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**这是</span></span><br><span class="line"><span class="comment">文档注释*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>Java 是大小写敏感的</li><li>类名：类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写</li><li>变量名、方法名、包名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写</li><li>常量：所有字母都大写</li><li>所有标识符都应该以：字母、美元符或下划线开始。关键字不能用作标识符</li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li>访问控制修饰符 : public , protected, default, private<ul><li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li></ul></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(同一包)</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left">Y</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><ul><li>非访问控制修饰符 : final, abstract, static, synchronized，transient，volatile</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符</p><ul><li>+、-、*、&#x2F;、%、++、–</li></ul><p>关系运算符</p><ul><li>&#x3D;&#x3D;、!&#x3D;、＞、＜、＞&#x3D;、＜&#x3D;</li></ul><p>位运算符</p><ul><li>&amp;、|、^、~、》、《<ul><li>&amp;：如果相对应位都是1，则结果为1，否则为0</li><li>|：如果相对应位都是 0，则结果为 0，否则为 1</li><li>^：如果相对应位值相同，则结果为0，否则为1</li><li>~：按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</li><li>》：按位右移运算符。左操作数按位右移右操作数指定的位数</li><li>《：按位左移运算符。左操作数按位左移右操作数指定的位数</li></ul></li></ul><p>逻辑运算符</p><ul><li>&amp;&amp;、||、！</li></ul><p>赋值运算符</p><ul><li>&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、（%）&#x3D;、《&#x3D;、》&#x3D;、&amp;&#x3D;、^&#x3D;、|&#x3D;</li></ul><p>条件运算符(三元运算符)</p><ul><li>格式：条件表达式？值1：值2</li><li>执行流程：首先计算关系表达式的值，如果为true，返回值1，如果为false，返回值2</li></ul><p>instanceof 运算符</p><ul><li>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</li></ul><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。<strong>无默认值</strong>、<strong>在栈内存</strong>，变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。<strong>有默认值、在堆内存</strong>，这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>内置数据类型(基本数据类型)</p><ul><li>byte：占1字节、范围是-128到127，默认值是0</li><li>boolean：占1字节、默认值是false</li><li>short：占2字节、范围是-32768到32767，默认值是0</li><li>char：占2字节</li><li>int：占4字节、范围是-2,147,483,648到2,147,483,647，默认值是0</li><li>float：占4字节、默认值是0.0</li><li>double：8字节、默认值是0.0</li><li>long：8字节、默认值是0</li><li>注意：<ul><li>随便写一个整数字面量默认是int类型的，如果想要当成long类型，需要在其后加l&#x2F;L</li><li>随便写一个小数字面量默认是double类型的，如果想要当成float类型，需要在其后加f&#x2F;F</li><li><strong>字符是char要用单引号’ ‘，字符串是String要用双引号” “</strong></li></ul></li></ul><p>引用数据类型</p><ul><li>类，接口，数组，String（默认值是null）</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>自动类型转换（向上转型）：类型范围小的变量可以直接赋值给类型范围大的变量<ul><li>注意：byte,short,char是直接转换成int类型参与运算的。</li><li>可以调用父类中可访问的所有成员和方法，不可以调用子类的特有成员和方法。</li></ul></li><li>强制类型转换（向下转型）：类型范围大的变量赋值给类型范围小的变量<ul><li>小数变成整数时会把小数部分丢掉</li><li>向下转型后，可以调用子类和父类可访问的所有成员</li></ul></li><li>注意：对象转型之后，属性看编译类型。方法看运行类型。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>静态初始化数组</p><ul><li><p>定义数组的时候直接给数组赋值</p></li><li><p>定义格式第一种:数据类型[] 数组名 &#x3D; new 数据类型[]{元素1，元素2，元素3,…};</p></li><li><p>定义格式第二种（简化）:数据类型[] 数组名 &#x3D; {元素1，元素2，元素3,…};  也可以把[]放在数组名后面</p></li><li><p>列如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>动态初始化数组</p><ul><li><p>定义数组的时候只确定元素的类型和数组的长度，之后再存入具体的数据</p></li><li><p>格式:数据类型[] 数组名 &#x3D; new 数据类型[长度]</p></li><li><p>列如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr [] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li></ul><p>二维数组</p><ul><li><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301727286.png" alt="image-20240408093849901"></p><p>栈内存</p><ul><li>存储<strong>局部变量</strong>，定义在方法里面的变量</li><li>栈内存的数据<strong>用完就释放</strong>。</li><li>在栈内存中<strong>保存的是堆内存空间的访问地址</strong>，栈内存会有个地址指向堆内存的地址</li><li>栈内存<strong>线程不共享</strong></li></ul><p>堆内存</p><ul><li><p>存储<strong>new出来的的内容</strong>（实体，对象）数组在初始化时，会<strong>为存储空间添加默认值</strong></p></li><li><p>每一个new出来的东西都有一个地址值，使用完毕，会在垃圾站回收器空间时被回收</p></li><li><p>堆内存是<strong>线程共享</strong>的</p></li></ul><p>方法区</p><ul><li>它存储已被Java虚拟机加载的<strong>类信息、常量、静态变量</strong>、即时编译器编译后的代码等。</li><li>方法区是<strong>线程共享</strong>的</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</li><li>格式：&lt;数据类型&gt;</li><li>Java中的泛型是伪泛型</li></ul><p>泛型的好处</p><ul><li><em><strong>统一数据类型</strong></em></li><li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常</li></ul><p>细节</p><ul><li>泛型只能支持<em><strong>引用数据类型</strong></em>。</li><li>如果不写泛型，<em><strong>默认是Object类型</strong></em><ul><li>此时可以往集合添加任意的数据类型。</li><li>带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。</li></ul></li></ul><p>泛型的通配符</p><ul><li>泛型不具备继承性，但是数据具备继承性<ul><li>此时要想泛型可以继承，可以使用泛型的通配符</li><li>? extends E：表示可以传递E或者E所有的子类类型</li><li>? super E：表示可以传递E或者E所有的父类类型</li></ul></li></ul><p>应用场景</p><ul><li>如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。</li><li>如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符</li></ul><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型通常写成：T、E、K、V。</span></span><br><span class="line">修饰符 class 类名&lt;类型&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;类型&gt; 返回值类型 方法名（类型 变量名）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常与错误"><a href="#异常与错误" class="headerlink" title="异常与错误"></a>异常与错误</h2><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301730664.png" alt="image-20231125145609247"></p><p>错误：由java虚拟机生成并抛出的异常，程序无法处理，通常指程序中出现的严重问题。</p><ul><li>Error（错误）是不可查的，而且也常常在应用程序的控制和处理能力之外，因此当Error（错误）出现时，程序会立即奔溃，Java虚拟机立即停止运行，</li></ul><p>异常：是指程序本身可以处理的异常（可以向上抛出或者捕获处理）。</p><ul><li>编译时异常：程序在编译过程中发现的异常，受检异常</li><li>运行时异常：又称非受检异常</li></ul><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ul><li>Java处理异常的默认方式是<strong>中断处理</strong>。</li><li>使用try、catch、finaly捕获异常后程序会继续执行；使用throws抛出的异常类型，出现异常后，程序终止</li></ul><p>自己处理（try catch finally）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现问题的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常名称)&#123;</span><br><span class="line"><span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常名称)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>catch中声明的异常类型应该和实际抛出的异常类型要么相同要么有继承关系</p></li><li><p>try块中有多行代码，都有可能出现异常信息时，程序执行的时候是从上往下执行的，当碰到异常情况的时候就会跳出try块，从而try块中剩余的代码就不会执行了，</p></li><li><p>finally修饰的代码一定会执行（前提是异常成功进入到了相应的try catch中）</p><ul><li><p>try语句中，在执行return语句时，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，因此，即使finally中对变量x进行了改变，但是不会影响返回结果。它应该使用栈保存返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        x++;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果输出为3和2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>printStackTrace()方法可以打印出详细的异常信息</p></li></ul><p>将异常抛出（throws和throw）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名(参数列表) [<span class="keyword">throws</span> 异常<span class="number">1</span>，异常<span class="number">2.</span>..]&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>throws关键字声明的方法表示此方法不处理异常而交给方法的调用者进行处理</li><li>在重写方法时，它所声明的异常范围不能被扩大</li><li>throws和throw的区别<ul><li>throws用在方法名后面，跟的是异常类名，throw是用在方法体重，跟的异常对象</li><li>throws可以跟多个异常类名，用逗号隔开throw只能抛出一个异常对象</li><li>throws表示抛出异常，由该方法的调用者来处理，throw表示抛出异常，由方法体内的语句处理</li></ul></li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>​Java中的异常都是Throwable或者Exception或者RuntimeException的子类，那么我们要创建一个自定义的异常，其实就是创建其对应的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 编写一个分数必须在0-100之间的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">0</span>||score&gt;<span class="number">100</span>)<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScoreException</span>(<span class="string">&quot;分数不可分法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (?)&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value3:</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断条件？值<span class="number">1</span>：值<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>普通for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;循环条件;迭代语句)&#123;</span><br><span class="line">            循环体语句;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>增强for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素数据类型 变量名∶数组或者collection集合)&#123;</span><br><span class="line">循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>普通while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do-while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表）&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项：<ul><li>如果方法的返回值类型为void（无返回值），方法内则不能使用return返回数据</li><li>如果方法的返回值类型写了具体类型，方法内部则必须使用return返回</li><li>java的参数传递都是值传递</li><li>基本类型的参数传输存储的数据值</li><li>引用类型的参数传输存储的地址值</li></ul></li></ul><h2 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h2><ul><li>重载(overloading) 是在同一个类(或子类)里面，<em><strong>方法名字相同，参数列表不同</strong></em>；返回类型和权限修饰符可以相同也可以不同；可以抛出新的或更广的异常</li><li>被重载的方法必须改变参数列表(参数个数或类型不一样)</li></ul><h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><ul><li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变</li><li>方法名、参数列表和返回类型都相同；权限修饰符要大于父类方法；不能抛出新的或者更广的异常</li><li>返回类型可以是父类返回值类型的子类。</li></ul><p>重写规则</p><ul><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>构造方法不能被重写。</li></ul><table><thead><tr><th>区别点</th><th>方法重载</th><th>方法重写</th></tr></thead><tbody><tr><td>参数列表</td><td><strong>必须修改</strong></td><td><strong>不能修改</strong></td></tr><tr><td>返回类型</td><td>可以修改</td><td>不能修改(可以是子类)</td></tr><tr><td>异常</td><td>可以修改</td><td>不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>可以降低限制</td></tr></tbody></table><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>当一个对象被创建时候，构造方法用来初始化该对象。</li><li>构造方法和它所在类的名字相同。</li><li>构造方法没有返回值，但可以有return，return在这里只是表示结束，并不是返回的表示。</li><li>默认构造方法的访问修饰符和类的访问修饰符相同</li><li>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法</li><li>一旦你定义了自己的构造方法，默认构造方法就会失效</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>类的五大成员：属性、方法、构造器、代码块、内部类</p><p>Java代码执行顺序：父类的静态代码块 –&gt; 子类的静态代码块 –&gt; 父类的普通代码块 –&gt; 父类的构造方法</p><p>–&gt; 子类的普通代码块 –&gt; 子类的构造方法</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装的概念"><a href="#封装的概念" class="headerlink" title="封装的概念"></a>封装的概念</h3><ul><li>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法</li><li>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问</li><li>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性</li><li>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段</li></ul><h3 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h3><ul><li>良好的封装能够减少耦合。</li><li>类内部的结构可以自由修改。</li><li>可以对成员变量进行更精确的控制。</li><li>隐藏信息，实现细节。</li></ul><h3 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h3><ul><li>修改属性的可见性来限制对属性的访问（一般限制为private）</li><li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h3><ul><li>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</li><li>继承需要符合的关系是：is-a，父类更通用，子类更具体</li></ul><h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><ul><li>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 父类&#123;</span><br><span class="line">&#125;</span><br><span class="line">class 子类 extends 父类&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ul><li>子类拥有父类非 private 的属性、方法</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</li><li>子类可以用自己的方式实现父类的方法</li><li>Java 的继承是单继承，但是可以多重继承</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</li></ul><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ul><li>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类</li></ul><h3 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h3><ul><li>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口</li></ul><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul><li>this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针</li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li>super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类</li></ul><p>super的用法</p><ul><li>每个子类构造方法的第一条语句，都是隐含地调用 super()</li></ul><ol><li>普通的直接引用<ul><li>与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员</li></ul></li><li>引用构造函数<ul><li>super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）</li><li>this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）</li></ul></li></ol><h3 id="this和super的特性"><a href="#this和super的特性" class="headerlink" title="this和super的特性"></a>this和super的特性</h3><ul><li>均不可以在 static 环境中使用</li><li>this 和 super 不能同时出现在一个构造函数里面</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3><ul><li>多态是同一个行为具有多个不同表现形式或形态的能力</li><li>多态性是对象多种表现形式的体现</li></ul><h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul><li><p>继承</p></li><li><p>重写</p></li><li><p>父类引用指向子类对象</p></li></ul><h3 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h3><ul><li>方法重写</li><li>接口</li><li>抽象类和抽象方法</li></ul><h3 id="多态中成员访问特点"><a href="#多态中成员访问特点" class="headerlink" title="多态中成员访问特点"></a>多态中成员访问特点</h3><ul><li>方法：编译看左边，运行看右边</li><li>变量：编译看左边，运行也看左边</li></ul><h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><ul><li>java中的<code>static</code>关键字主要用于内存管理</li><li>实用范围：static可以用在变量、方法、代码块和嵌套类<ul><li>变量：称为类变量、静态变量</li><li>方法：称为类方法、静态方法</li><li>代码块：称为静态代码块</li><li>嵌套类：称为静态内部类</li></ul></li><li>静态成员变量和方法的访问：类名.静态成员变量&#x2F;方法(推荐)、对象.静态成员变量&#x2F;方法(不推荐)</li><li>特点<ul><li><strong>静态方法只能访问静态成员和方法，不可以“直接”访问实例成员和方法</strong></li><li>随着类的加载而被加载</li><li>优先于对象存在，被所有对象共享</li><li>局部变量不能被static修饰</li></ul></li></ul><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li><p>final是一个关键字，可以用于修饰类，成员变量，成员方法</p></li><li><p>特点</p><ul><li>它修饰的类不能被继承。</li><li>它修饰的成员变量是一个常量</li><li>它修饰的成员方法是不能被子类重写的</li></ul></li><li><p><strong>final修饰成员变量,必须初始化</strong></p></li><li><p>final修饰的常量定义一般都有书写规范,被final修饰的常量名称,所有字母都大写</p></li><li><p>final修饰的变量只能在显示初始化或者构造函数初始化的时候赋值一次，以后不允许更改</p></li></ul><h2 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h2><ul><li>用abstract关键字</li></ul><p>特点</p><ul><li>抽象类不能被实例化，如果被实例化，就会报错，编译无法通过</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li><li>抽象类中的抽象方法只是声明，不包含方法体</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</li><li>抽象方法不能使用private、static、final修饰</li></ul><h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><ul><li>用interface关键字</li></ul><p>特点</p><ul><li>接口不能用于实例化对象</li><li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法</li><li>接口不能包含成员变量，除了 static 和 final 变量</li><li>接口不是被类继承了，而是要被类实现</li><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</li></ul><p>抽象类和接口的不同点和相同点</p><ul><li><p>相同点</p><ul><li>都不能实例化</li><li>子类都必须实现抽象方法</li></ul></li><li><p>不同点</p><ul><li><p>抽象类可以有构造方法，而接口没有</p></li><li><p>抽象类可以包含普通方法和代码块，接口里只能包含抽象方法，静态方法和默认方法</p></li><li><p>抽象类中的成员变量可以是各种类型的，接口的成员变量只能是 <strong>public static final</strong> 类型的，并且必须赋值</p></li><li><p>一个类只能继承一个抽象类，但可以实现多个接口</p></li><li><p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范</p></li></ul></li></ul><table><thead><tr><th></th><th>抽象</th><th>接口</th></tr></thead><tbody><tr><td>组成</td><td>构造方法、抽象方法、普通方法、常量、变量</td><td>常量、抽象方法（jdk8：默认方法、静态方法）</td></tr><tr><td></td><td>is</td><td>like</td></tr></tbody></table><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类嵌套在另一个类里面或者一个方法里面，被嵌套的类称为内部类。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义</p><ul><li>成员内部类是最普通的内部类，它的定义为位于另一个类的内部</li></ul><p>内访外</p><ul><li><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</p></li><li><p>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="built_in">this</span>.成员变量</span><br><span class="line">外部类.<span class="built_in">this</span>.成员方法</span><br></pre></td></tr></table></figure></li></ul><p>外访内</p><ul><li>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问，创建成员内部类的对象</li></ul><p>创建对象格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名=<span class="keyword">new</span>外部类构造器.new内部类构造器</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义</p><ul><li>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</li></ul><p>内范外</p><ul><li>直接访问外部类的所有成员（包括私有成员）</li><li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类成员，则可以使用（外部类名.this.成员）访问</li></ul><p>外访内</p><ul><li>创建对象再访问</li></ul><p>特点</p><ul><li>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的,可以使用final.</li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>定义</p><ul><li>本质上是一个没有名字的局部内部类，定义在方法、代码块中</li></ul><p>特点</p><ul><li>匿名内部类也是不能有访问修饰符和 static 修饰符</li><li>大部分匿名内部类用于接口回调。</li><li>匿名内部类是唯一一种没有构造器的类。</li><li>匿名内部类可以作为方法的实际参数进行传输</li></ul><p>创建对象格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类|抽象类名|或接口名（）&#123;重写方法&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>定义</p><ul><li>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</li></ul><p>特点</p><ul><li>静态内部类是不需要依赖于外部类的</li><li>它不能使用外部类的非static成员变量或者方法</li></ul><h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h2><ul><li>定义枚举类的格式:修饰符 enum 枚举名称{第一行都是罗列枚举类实例的名称}</li><li>枚举做信息标志和分类:代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术!建议使用</li><li>枚举类都是继承了枚举类型:java.lang.Enum</li><li>枚举都是最终类，不可以被继承</li><li>构造器的构造器都是私有的，枚举对外不能创建对象</li><li>枚举类的第一行默认都是罗列枚举对象的名称的</li><li>枚举类相当于是多例模式</li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合和泛型都<strong>只能支持引用数据类型</strong>，不支持基本数据类型，所以集合中存储的元素都认为是对象</p><h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><h3 id="Collection特点"><a href="#Collection特点" class="headerlink" title="Collection特点"></a>Collection特点</h3><p>Collection是<em><strong>单列</strong></em>集合的祖宗接口，它的功能是全部单列集合都可以继承使用的</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301730101.png" alt="image-20240311202352087"></p><h3 id="Collection通用API"><a href="#Collection通用API" class="headerlink" title="Collection通用API"></a>Collection通用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>把给定的对象添加到当前集合中</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>清空集合中所有的元素</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>把给定的对象在当前集合中删除</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>判断当前集合中是否包含给定的对象</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>判断当前集合是否为空</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>返回集合中元素的个数。</span><br><span class="line"><span class="keyword">public</span> Object[] toArray()把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure><ul><li>remove：因为Collection里面定义的是共性的方法，所以此时不能通过索引进行删除。只能通过元素的对象进行删除。</li><li>cotains<ul><li>contains方法在底层依赖equals方法判断对象是否一致的。</li><li>如果存的是自定义对象，没有重写equals方j法，那么默认使用object类中的equals方法进行判断，而object类中equals方法，依赖地址值进行判断。</li><li>所以，需要在自定义的Javabean类中，重写equals方法就可以了。</li></ul></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特点</p><ul><li>List系列集合：添加的元素是<em><strong>有序、可重复、有索引</strong></em></li></ul><p>List集合特有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,E element)</span>在此集合中的指定位置插入指定的元素</span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>删除指定索引处的元素，返回被删除的元素</span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,E element)</span>修改指定索引处的元素，返回被修改的元素</span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>返回指定索引处的元素</span><br></pre></td></tr></table></figure><ul><li>add：添加后，原来索引处上的元素会依次往后移</li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>底层原理</p><ul><li>ArrayList底层是<em><strong>基于数组实现的</strong></em>，根据索引定位元素快，增删需要做元素的移位操作</li><li>利用空参创建的集合，在底层创建一个默认长度为0的数组，数组名为elementData</li><li>添加第一个元素时，底层会创建一个新的长度为<em><strong>10</strong></em>的数组</li><li>存满时，会扩容<em><strong>1.5</strong></em>倍</li><li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li></ul><h4 id="LinekdList"><a href="#LinekdList" class="headerlink" title="LinekdList"></a>LinekdList</h4><p>底层原理</p><ul><li>底层数据结构是<em><strong>双向链表</strong></em>，<em><strong>查询慢，增删快</strong></em>，但是如果操作的是首尾元素，速度也是非常快的</li></ul><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731667.png" alt="image-20240313110643515"></p><p>- </p><p>特有API</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731222.png" alt="image-20240313110333982"></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li>HashSet：<em><strong>无序、不重复、无索引</strong></em></li><li>TreeSet：按照大小<em><strong>默认升序排序、不重复、无索引</strong></em></li></ul><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><h3 id="Map特点"><a href="#Map特点" class="headerlink" title="Map特点"></a>Map特点</h3><ul><li>Map属于双列集合，双列集合一次需要存一对数据，分别为键和值</li><li>键和值是一 一对应的,每一个键只能找到自己对应的值</li><li>Map集合的键是<strong>不重复的，无索引</strong>的</li><li>键＋值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”</li><li>Map集合的键值对都可以为null</li></ul><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731968.png" alt="image-20240313151307847"></p><h3 id="Map通用API"><a href="#Map通用API" class="headerlink" title="Map通用API"></a>Map通用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">put</span><span class="params">(K key,v value)</span>添加元素</span><br><span class="line">v <span class="title function_">remove</span><span class="params">(0bject key)</span>根据键删除键值对元素</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>移除所有的键值对元素</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(object key)</span>判断集合是否包含指定的键</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(0bject value)</span>判断集合是否包含指定的值</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>判断集合是否为空</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>集合的长度，也就是集合中键值对的个数</span><br></pre></td></tr></table></figure><ul><li>put：添加时，如果键已经存在，就会覆盖原来，并返回原理的值</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>特点</p><ul><li>元素按照键是<em><strong>无序，不重复，无索引</strong></em>的</li><li>HashMap跟HashSet底层原理是一模一样的，都是<em><strong>哈希表结构</strong></em>。依赖hashCode方法和equals方法保证键的唯一</li><li>如果键存储的是自定义对象，需要重写hashCode和equals方法如果值存储自定义对象，不需要重写hashCode和equals方法</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>特点</p><ul><li>元素按照键是<em><strong>有序，不重复，无索引</strong></em>的<ul><li>这里的有序指的是保证存储和取出的元素顺序一致</li></ul></li><li>底层数据结构是依然<em><strong>哈希表</strong></em>，只是每个键值对元素又额外的多了一个<em><strong>双链表</strong></em>的机制记录存储的顺序</li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>特点</p><ul><li>TreeMap跟TreeSet底层原理一样，都是红黑树结构的。</li><li>元素按照键是<em><strong>不重复、无索引、可排序</strong></em>的<ul><li>可排序是对键进行排序。<ul><li>方法一：实现Comparable接口，指定比较规则。</li><li>方法二：</li><li>创建集合时传递Comparator比较器对象，指定比较规则。</li></ul></li><li>默认按照键的从小到大进行排序，也可以自己规定键的排序规则</li></ul></li></ul><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><p>遍历方式的选择</p><table><thead><tr><th>遍历方式</th><th>选择情况</th></tr></thead><tbody><tr><td>迭代器</td><td>在遍历的过程中需要<em><strong>删除</strong></em>元素，请使用迭代器。</td></tr><tr><td>列表迭代器</td><td>在遍历的过程中需要<em><strong>添加</strong></em>元素，请使用列表迭代器。</td></tr><tr><td>增强for循环</td><td>仅仅想遍历，那么使用增强for或Lambda表达式。</td></tr><tr><td>Lambda表达式</td><td>仅仅想遍历，那么使用增强for或Lambda表达式。</td></tr><tr><td>普通for</td><td>如果遍历的时候想<em><strong>操作索引</strong></em>，可以用普通for。</td></tr></tbody></table><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>特点</p><ul><li>在Java中的代表是***lterator()***，迭代器是集合的专用遍历方式</li><li>迭代器不依赖索引</li><li>迭代器就好比是一个箭头，默认指向集合的0索引处</li></ul><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="comment">//询问当前位置是否有元素存在，存在返回true ,不存在返回false</span></span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span> <span class="comment">//获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> <span class="comment">//删除当前获取到的元素</span></span><br></pre></td></tr></table></figure><p>迭代器遍历格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;集合中元素的类型&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">集合中元素的类型 变量名 = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节和注意事项</p><ul><li>当指到最后一个位置时，如果还继续用next，就会报错NoSuchElementException</li><li>迭代器遍历完毕，指针不会复位循环中</li><li>在循环中最好不要用两个或以上次数的next方法</li><li>迭代器遍历时，<em><strong>不能用集合的方法</strong></em>进行增加或者删除，可以用迭代器提供的remove删除</li></ul><h4 id="增强for遍历"><a href="#增强for遍历" class="headerlink" title="增强for遍历"></a>增强for遍历</h4><p>特点</p><ul><li>增强for的底层就是迭代器，为了简化迭代器的代码书写的。</li><li>它是JDK5之后出现的，其内部原理就是一个lterator迭代器</li><li>所有的<em><strong>单列集合和数组</strong></em>才能用增强for进行遍历。</li></ul><p>增强for遍历格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(集合中元素的数据类型 变量名:数组或者集合)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>细节和注意事项</p><ul><li>修改增强for中的变量，不会改变集合中原本的数据。</li></ul><h4 id="Lambda表达式遍历"><a href="#Lambda表达式遍历" class="headerlink" title="Lambda表达式遍历"></a>Lambda表达式遍历</h4><p>lambda表达式特点</p><ul><li>()-&gt;{}</li></ul><p>Lambda表达式遍历格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">集合名.forEach((集合中元素的数据类型 变量名)-&gt;&#123;</span><br><span class="line">   循环体...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果循环体只有一行代码，则可以简化成以下形式</span></span><br><span class="line">集合名.forEach(变量名 -&gt; 循环体);</span><br></pre></td></tr></table></figure><h4 id="列表迭代器-List特有"><a href="#列表迭代器-List特有" class="headerlink" title="列表迭代器(List特有)"></a>列表迭代器(List特有)</h4><p>特点</p><ul><li>listIterator()</li><li>List集合特有的遍历方式</li></ul><p>特有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span><span class="comment">//将指定元素插入列表</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过keySet方法，得到一个包含所有key的单列集合</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.遍历包含键的单列集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    <span class="comment">//3.通过get方法得到键对应的值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过entrySet方法，得到一个包含所有键值对的单列集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">//2.遍历包含键值对的单列集合</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entrySet) &#123;</span><br><span class="line"><span class="comment">//3.通过getKey()、和getValue()得到对应的键和值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(entry.getKey()+<span class="string">&quot;:&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><ul><li>作用：结合了Lambda表达式，简化集合、数组的操作</li></ul><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><ul><li>不可变是指不能增删改，只能查</li></ul><p>不可变list集合</p><ul><li>List.of(E….elements);</li></ul><p>不可变Set集合</p><ul><li>Set.of(E….elements)</li><li>注意，Set是无重复的。</li></ul><p>不可变Map集合</p><ul><li>Map.of( K k1,V v1,K k2, V v2…)</li><li>注解，key是不能重复的</li><li>最多只能传20个参数，也就是10个键值对。</li><li>如果要传超过10个以上的键值对可以用Map.copyOf(Map map)方法，注意，此方法在jdk9之后才有</li></ul><h3 id="Stream的使用步骤"><a href="#Stream的使用步骤" class="headerlink" title="Stream的使用步骤"></a>Stream的使用步骤</h3><ol><li><p>先得到一条Stream流，并把数据放上去</p><table><thead><tr><th>获取方式</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>单列集合</td><td>default Stream<E> stream()</td><td>Collection中的默认方法</td></tr><tr><td>双列集合</td><td>无（可以用keySet和entrySet）</td><td>无法直接使用stream流</td></tr><tr><td>数组</td><td>public static <T> Stream<T> stream(T[]array)</td><td>Arrays工具类中的静态方法</td></tr><tr><td>一堆零散数据</td><td>public static<T> Stream<T> of(T…values)</td><td>Stream接口中的静态方法</td></tr></tbody></table><ul><li>单列集合：list.stream()</li><li>双列集合：map.keySet().stream()</li><li>数组：Arrays.stream(arr)</li><li>零散数据：Stream.of(T…values)</li></ul></li><li><p>Stream流常见的中间方法</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Stream<T> <strong>filter</strong>(Predicate&lt;? super T&gt; predicate)</td><td>过滤</td></tr><tr><td>Stream<T> <strong>limit</strong>(long maxSize)</td><td>获取前几个元素</td></tr><tr><td>Stream<T> <strong>skip</strong>(long n)</td><td>跳过前几个元素</td></tr><tr><td>Stream<T> <strong>distinct</strong>()</td><td>元素去重，依赖（hashCode和equals方法）</td></tr><tr><td>static <T> Stream<T> <strong>concat</strong>(Stream a, Stream b)</td><td>合并a和b两个流</td></tr><tr><td>Stream<R> <strong>map</strong>(Function&lt;T ,R&gt; mapper)</td><td>转换流中的数据类型</td></tr></tbody></table><ul><li>注意1：中间方法，返回新的Stream流，原来的Stream流只能使用一次，建议使用链式编程</li><li>注意2：修改Stream流中的数据，不会影响原来集合或者数组中的数据</li></ul></li><li><p>Stream流的终结方法</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>void <strong>forEach</strong>(Consumer action)</td><td>遍历</td></tr><tr><td>long <strong>count</strong>()</td><td>统计</td></tr><tr><td><strong>toArray</strong>()</td><td>收集流中的数据，放到数组中</td></tr><tr><td>**collect(**Collector collector)</td><td>收集流中的数据，放到集合中</td></tr></tbody></table></li></ol><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><ul><li><p>作用：获取文件本身的信息，删除文件，创建文件等功能</p></li><li><p>File类创建对象：</p><ul><li><pre><code class="java">File f = new File(pathname);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - pathname支持绝对路径（从盘符开始），也支持相对路径（不带盘符）</span><br><span class="line">  - 相对路径默认直接到当前工程下的目录寻找文件</span><br><span class="line">  - 路径用双反斜杠或斜杠/</span><br><span class="line"></span><br><span class="line">- 常用API：</span><br><span class="line"></span><br><span class="line">  - getAbsolutePath()：获取文件的绝对路径</span><br><span class="line">  - getPath()：获取文件定义时所用的路径</span><br><span class="line">  - getName()：获取文件的名称（带后缀）</span><br><span class="line">  - length()：获取文件大小（**字节**个数）</span><br><span class="line">  - lastModified()：获取文件的最后修改时间</span><br><span class="line">  - isFile()和isDirectory()：判断文件是文件还是文件夹</span><br><span class="line">  - createNewFile()：创建新文件</span><br><span class="line">  - delete()：删除文件</span><br><span class="line">  - mkdir()：创建一级目录</span><br><span class="line">  - mkdirs()：创建多级目录</span><br><span class="line">  - 常用来遍历的API：</span><br><span class="line">    - list()：获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span><br><span class="line">    - listFiles()：获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回</span><br><span class="line"></span><br><span class="line">## **IO流**</span><br><span class="line"></span><br><span class="line">- 作用：读写文件数据</span><br><span class="line">- 分为两大类：字节流和字符流</span><br><span class="line"></span><br><span class="line">### 编码和解码</span><br><span class="line"></span><br><span class="line">- 英文，数字，符号一般占1个字节</span><br><span class="line">- GBK中，中文占2个字节</span><br><span class="line">- UTF-8中，中文占3个字节</span><br><span class="line"></span><br><span class="line">- 编码</span><br><span class="line">  - str.getBytes(编码格式)：编码格式默认是utf-8，返回类型是一个byte类型的数组</span><br><span class="line">- 解码</span><br><span class="line">  - new String(bytes,解码格式)：解码格式默认是utf-8，返回类型是字符串</span><br><span class="line"></span><br><span class="line">### 字节流</span><br><span class="line"></span><br><span class="line">- 字节输入流（InputStream）</span><br><span class="line"></span><br><span class="line">  - InputStream是一个抽象类，其实现类常用FileInputStream</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    InputStream inputStream = new FileInputStream（path）;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>常用API</p><ul><li><p>read()：每次读取一个字节返回，返回的是该字节的编码，如果字节已无可读内容则返回-1</p></li><li><p>**readAllBytes()**：读取全部字节，返回的是一个byte类型的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(new String(inputStream.readAllBytes()));</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>字节输出流（OutputStream）</p><ul><li><p>OutputStream是一个抽象类，其实现类常用FileOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path,append);</span><br></pre></td></tr></table></figure><ul><li>默认会清空之前的数据，如果想追加的话就在括号里加个true</li></ul></li><li><p>常用API</p><ul><li><p>write(int a)：写入一个字节</p></li><li><p>**write(byte[] bytes)**：写一个字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(<span class="string">&quot;卢家业呀&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>flush()：刷新数据</p></li><li><p>close()：关闭流，关闭包含刷新，关闭后流不可以继续使用了</p></li></ul></li></ul></li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul><li><p>字符输入流（Reader）</p><ul><li><p>Reader是一个抽象类，其实现类常用FileReader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = new FileReader(path);</span><br></pre></td></tr></table></figure></li><li><p>常用API</p><ul><li>read()：每次读取一个字节返回，返回的是该字节的编码，如果字节已无可读内容则返回-1</li></ul></li></ul></li><li><p>字符输出流（Writer）</p><ul><li><p>Writer是一个抽象类，其实现类常用FileWriter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = new FileWriter(path,append);</span><br></pre></td></tr></table></figure></li><li><p>常用API</p><ul><li><p>write()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.write(str);</span><br></pre></td></tr></table></figure></li><li><p>flush()：刷新数据</p></li><li><p>close()：关闭流，关闭包含刷新，关闭后流不可以继续使用了</p></li></ul></li></ul></li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>进程：进程是程序的基本执行实体</li><li>线程：线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</li><li>多线程的作用：可以让程序同时做多件事情，提高运行效率</li><li>并发：在同一时刻，有多个指令在单个CPU上<strong>交替</strong>执行</li><li>并行：在同一时刻，有多个指令在多个CPU上<strong>同时</strong>执行</li></ul><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><p>主线程应该放在子线程之后</p><ul><li><p>方式一：继承Thread类</p><ol><li>定义一个类继承Thread</li><li>重写run方法，里面是定义线程以后要干啥</li><li>创建一个该类的对象</li><li>调用start方法启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式一：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLearn</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;<span class="comment">//1.继承Thread类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//2.重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程正在输出&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLearn</span>();<span class="comment">//3.创建一个该类的对象</span></span><br><span class="line">        thread.start();<span class="comment">//4.调用start方法启动线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程正在输出&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二： 实现Runnable接口</p><ol><li>实现Runnable接口</li><li>重写run方法</li><li>创建一个该类对象</li><li>把该对象交给Thread线程对象处理</li><li>调用start方法，启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程方式二：实现Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;<span class="comment">//1.实现Runnable接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//2.重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程1正在输出&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>();<span class="comment">//3.创建一个该类的对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);<span class="comment">//4.把该对象交给Thread线程对象处理</span></span><br><span class="line">    thread1.start();<span class="comment">//5.调用start方法，启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以用匿名内部类或lambda表达式的方法来简化代码</span></span><br></pre></td></tr></table></figure></li><li><p>方法三：实现Callable接口，结合FutureTask完成（改方法可以获取多线程运行的结果）</p><ol><li>实现Callable接口，应申明线程任务执行完毕后的结果的数据类型</li><li>重写call方法</li><li>创建该类对象</li><li>把该对象交给FutureTask对象</li><li>再把FutureTask对象交给Thread对象处理</li><li>调用start方法</li><li>可通过调用FutureTask对象的get方法获取线程执行完毕后的结果</li></ol></li></ul><p>三种实习方式对比</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731271.png" alt="image-20231120210301967"></p><p>多线程的书写套路</p><ol><li>循环</li><li>同步代码块（同步方法）</li><li>判断共享数据是否到了末尾（到了末尾就break）</li><li>判断共享数据是否到了末尾（没到末尾就执行核心逻辑）</li></ol><h2 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h2><ul><li>setName(String name)：给线程命名 <ul><li>如果没有给线程命名，它也有默认的名字:Thread-X。</li><li>Thread的构造方法也可以给线程命名</li></ul></li><li>getName()：获取线程的名字</li><li>currentThread()：获取当前的线程对象</li><li>sleep(long time): 让线程休眠指定的时间，单位为毫秒</li><li>setPriority(int newPriority): 设置线程的优先级<ul><li>默认是5，最小是1，最大是10</li><li>线程的优先级越高只是会让它执行的概率变高。</li></ul></li><li>getPriority(): 获取线程的优先级</li><li>setDaemon(boolean on): 设置为守护线程<ul><li>当其他的非守护线程执行完毕之后，守护线程会<strong>陆续结束</strong></li></ul></li><li>yield(): 出让&#x2F;礼让线程<ul><li>尽可能的让线程交替执行</li></ul></li><li>join(): 插入&#x2F;插队线程<ul><li>让某个线程执行完后再执行其他线程</li></ul></li></ul><h2 id="线程的生命周期和安全问题"><a href="#线程的生命周期和安全问题" class="headerlink" title="线程的生命周期和安全问题"></a>线程的生命周期和安全问题</h2><p>生命周期</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731054.png" alt="image-20231118180413483"></p><p>安全问题</p><ul><li>线程在执行代码的时候，cpu的执行权，随时有可能被其他线程抢走（随机性）<ul><li>解决方式：把操作共享数据的代码锁起来</li></ul></li><li>死锁问题： 一种线程间互相等待的状态，导致程序无法正常运行</li></ul><p>线程的六种状态</p><ul><li>新建：至今尚未启动的线程处于这种状态。</li><li>就绪start：正在Java虚拟机中执行的线程处于这种状态。</li><li>阻塞：受阻塞并等待某个监视器锁的线程处于这种状态。</li><li>无限期等待wait：无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。</li><li>计时等待sleep：等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。</li><li>结束：已退出的线程处于这种状态。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>synchronized锁</p><ul><li><p>同步代码块</p><ul><li><p>格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;操作共享数据的代码&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>锁默认打开，有一个线程进去了,锁自动关闭</li><li>里面的代码全部执行完毕,线程出来,锁自动打开</li></ul></li><li><p>注意</p><ul><li>锁对象是任意的一个对象，它一定要是唯一的</li></ul></li></ul></li><li><p>同步方法</p><ul><li><p>格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名 （方法参数）&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点</p><ul><li>同步方法是锁住方法里面所有的代码</li><li>锁对象不能自己指定</li></ul></li><li><p>注意</p><ul><li>非静态的方法的锁对象是this，静态的方法的锁对象是当前的字节码文件对象</li><li>StringBuilder的方法是线程不安全的，StringBuffer的方法是线程安全的</li></ul></li></ul></li></ul><p>lock锁</p><ul><li>注意<ul><li>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作</li><li>Lock中提供了获得锁lock() 和 释放锁unlock()的方法</li><li>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</li><li>ReentrantLock的构造方法ReentrantLock():创建一个ReentrantLock的实例</li></ul></li></ul><h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p>常见方法</p><ul><li>wait()：当前线程等待，直到被其他线程唤醒</li><li>notify()：随机唤醒单个线程</li><li>notifyAll()：唤醒所有线程</li></ul><p>阻塞队列</p><ul><li>ArrayBlockingQueue：底层是数组，有界的</li><li>LinkBlockingQueue：底层是链表，石界但不是真正的干界,最大为int的最七值。</li><li>put数据时：放不进去，会等着，也叫做阻塞。</li><li>take数据时：取出第一个数据，取不到会等着，也叫做阻塞。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>原理</p><ol><li>创建一个池子，池子中是空的</li><li>提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可</li><li>但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程任务就会排队等待</li></ol><p>代码实现</p><ol><li>创建线程池<ul><li>方法一（创建一个无上限的线程池）：ExecutorService pool &#x3D; Executors.newCachedThreadPool();</li><li>方法二（创建一个有上限的线程池）：ExecutorService pool &#x3D; Executors.newFixedThreadPool(int i);</li></ul></li><li>提交任务<ul><li>pool.submit(new MyThread());</li></ul></li><li>销毁线程池<ul><li>pool.shutdown();</li></ul></li></ol><p>自定义线程池</p><ul><li>ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);<ul><li>参数一：核心线程数量，不能小于0</li><li>参数二：最大线程数，不能小于e，最大数量&gt;&#x3D;核心线程数量</li><li>参数三：空闲线程最大存活时间，不能小于0</li><li>参数四：时间单位，用TimeUnit指定</li><li>参数五：任务队列，不能为null</li><li>参数六：创建线程工厂，不能为null</li><li>参数七：任务的拒绝策略，不能为null</li></ul></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>介绍</p><ul><li>ThreadLocal并不是一个Thread，而是Thread的局部变量</li><li>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</li><li>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</li></ul><p>常用方法</p><ul><li>set：设置当前线程的线程局部变量的值</li><li>get：返回当前线程所对应的线程局部变量的值</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>Java的线程默认是采用抢占式调度（随机）的。可以通过设置优先级的方式，使线程抢占的概率更高。</li><li>堆内存是唯一的，而每个线程都有自己的栈内存</li></ul><h1 id="Java高级"><a href="#Java高级" class="headerlink" title="Java高级"></a>Java高级</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="认识反射"><a href="#认识反射" class="headerlink" title="认识反射"></a>认识反射</h3><ul><li>反射就是∶加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）</li><li>简单来说就是：获取类的信息、操作它们。</li></ul><p>反射的引用场景</p><ul><li>反射的作用<ul><li>可以得到一个类的全部成分然后操作。</li><li>可以破坏封装性。</li></ul></li><li>主要用途：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</li></ul><h3 id="获取类"><a href="#获取类" class="headerlink" title="获取类"></a>获取类</h3><p>获取类的三种方式</p><ol><li>Class c1&#x3D;类名.class</li><li>调用Class提供方法：public static Class forName(String package);<ul><li>package是全类名（文件在项目中的位置）</li></ul></li><li>object提供的方法：public Class getClass();<ul><li>如：Class c3&#x3D;对象.getClass();</li></ul></li></ol><ul><li>获取类名之后就可以获取类中的成员变量、方法、构造器了</li></ul><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>获取构造器的方法</p><ol><li>Constructor&lt;?&gt;[]  getconstructors()：获取全部由public修饰的构造器</li><li>Constructor&lt;?&gt;[]  getDeclaredConstructors：获取全部构造器</li><li>Constructor＜T＞ getconstructor(class&lt;?&gt;… parameterTypes)：获取某个由public修饰的构造器</li><li>Constructor＜T＞ getDeclaredConstructor(class&lt;?&gt;… parameterTypes)：获取某个构造器</li></ol><p>获取构造器的作用：依然是初始化对象返回</p><ul><li>T newInstance(Object… initargs)：调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回，只能调用非私有的构造器</li><li>public void setAccessible(boolean flag)：设置为true，表示禁止检查访问控制（暴力反射)，使得私有的构造器也能调用</li></ul><h3 id="获取类的成员变量"><a href="#获取类的成员变量" class="headerlink" title="获取类的成员变量"></a>获取类的成员变量</h3><p>获取成员变量的方法</p><ol><li>public Field[] getFields()：获取类的全部成员变量（只能获取public修饰的)</li><li>public Field[] getDeclaredFields()：获取类的全部成员变量（只要存在就能拿到)</li><li>public Field getField(string name)：获取类的某个成员变量（只能获取public修饰的)</li><li>public Field getDeclaredField(string name)：获取类的某个成员变量（只要存在就能拿到)</li></ol><p>获取成员变量的作用：依然是赋值和取值</p><ul><li>void set(object obj, object value) ：赋值</li><li>object get(object obj)：取值</li><li>public void setAccessible(boolean flag)：设置为true，表示禁止检查访问控制（暴力反射)</li></ul><h3 id="获取类的成员方法"><a href="#获取类的成员方法" class="headerlink" title="获取类的成员方法"></a>获取类的成员方法</h3><p>获取类的成员方法的方式</p><ol><li>Method[ ] getMethods()：获取类的全部成员方法（只能获取public修饰的)</li><li>Method[] getDeclaredMethods()：获取类的全部成员方法(只要存在就能拿到)</li><li>Method getMethod(String name,class&lt;?&gt;… parameterTypes)：获取类的某个成员方法(只能获取public修饰的)</li><li>Method getDeclaredMethod(String name,class&lt;?&gt;… parameterTypes)：获取类的某个成员方法(只要存在就能拿到)</li></ol><p>成员方法的作用:依然是执行</p><ul><li>public object invoke(object obj, object. . . args)：触发某个对象的该方法执行。</li><li>public void setAccessible(boolean flag)：设置为true，表示禁止检查访问控制（暴力反射)</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="认识注解"><a href="#认识注解" class="headerlink" title="认识注解"></a>认识注解</h3><p>注解（Annotation）</p><ul><li>就是Java代码里的特殊标记，比如: @Override、@Test等</li><li>作用是让其他程序根据注解信息来决定怎么执行该程序。</li><li>注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处。</li><li>注解本质是一个接口，Java中所有注解都是继承了Annotation接口的。  </li><li>@注解(…):其实就是一个实现类对象，实现了该注解以及Annotation接口。</li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">publiuc <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line"><span class="keyword">public</span> 属性类型 属性名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果注解中只有一个value属性，使用注解时，value名称可以不写。</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul><li>元注解的作用：用来修饰注解的注解。</li></ul><p>@Target(ElementType.XXX)</p><ul><li>作用：声明被修饰的注解只能在哪些位置使用</li><li>TYPE：类接口</li><li>FIELD：成员变量</li><li>METHOD：成员方法</li><li>PARAMETER：方法参数</li><li>CONSTRUCTOR：构造器</li><li>LOCAL_VARIABLE：局部变量</li></ul><p>@Retention(RetentionPolicy.XXX)</p><ul><li>作用：声明注解的保留周期</li><li>SOURCE：只作用在源码阶段，字节码文件中不存在。</li><li>CLASS（默认值）：保留到字节码文件阶段，运行阶段不存在。</li><li>RUNTIME（开发常用）：一直保留到运行阶段。</li></ul><h3 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h3><ul><li><p>判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来。</p></li><li><p>要解析谁上面的注解，就应该先拿到谁（通过反射）</p></li><li><p>AnnotatedElement接口提供了解析注解的方法</p><ul><li>public Annotation[] getDeclaredAnnotations()：获取当前对象上面的注解。</li><li>public T getDeclaredAnnotation(class<T> annotationclass)：获取指定的注解对象</li><li>public boolean isAnnotationPresent(class<Annotation> annotationclass)：判断当前对象上是否存在某个注解</li></ul></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="认识动态代理"><a href="#认识动态代理" class="headerlink" title="认识动态代理"></a>认识动态代理</h3><ul><li>对象如果嫌身上干的事太多的话,可以通过代理来转移部分职责。</li><li>对象有什么方法想被代理，代理就一定要有对应的方法</li></ul><h1 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h1><h2 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>网络通信三要素：IP地址、端口、协议</li><li>IP地址：<strong>设备</strong>在网络中的地址，是唯一的标识<ul><li>常见的IP分类为：IPv4（4字节（32位））和IPv6（16字节（128位））</li><li>DNS服务器：也称域名解析器，可将域名解析成IP地址</li><li>IP地址的形式：公网地址、和私有地址（局域网使用）</li><li>局域网（以太网）：专门为组织机构内部使用，常以192.168.开头，范围是192.168.0.0—192.168.255.255</li><li>IP常用命令：ipconfig（查看本机IP地址），ping IP地址（检查网络是否连通）</li><li>本机IP地址：127.0.0.1或localhost</li></ul></li><li>端口：<strong>应用程序</strong>在设备中唯一的标识<ul><li>端口号:标识正在计算机设备上运行的进程（程序），被规定为一个16位的二进制，范围是0~65535。</li><li>周知端口:0~1023，被预先定义的知名应用占用（如:HTTP占用80，FTP占用271</li><li>注册端口:1024~49151，分配给用户进程或某些应用程序。(如:Tomcat占用8080，MySQL占用3306)</li><li>动态端口:49152到65535。之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配。</li><li>注意：一个设备中不能出现两个程序的端口号一样</li></ul></li><li>协议：数据在网络中传输的规则<ul><li>OSI参考模型:世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</li><li>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议):事实上的国际标准。<ul><li>应用层：HTTP、FTP、DNS、SMTP…</li><li>传输层：TCP、UDP…</li><li>网络层：IP、ICMP…</li><li>数据链路层+物理层：物理寻址、比特流…</li></ul></li><li>传输层的两个常见协议<ul><li>TCP：传输控制协议（连接，可靠）</li><li>UDP：用户数据报协议（不连接，不可靠）</li></ul></li></ul></li></ul><h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><ul><li>此类表示Internet协议（IP）地址</li><li>常用API<ul><li>InetAddress getLocalHost()：返回本主机的地址对象</li><li>InetAddress getByName(String host):得到指定主机的IP地址对象，参数是域名或者IP地址</li><li>String getHostName():获取此IP地址的主机名（域名）</li><li>String getHostAddress():返回IP地址字符串</li><li>boolean isReachable(int timeout):在指定毫秒内连通该IP地址对应的主机，连通放回true</li></ul></li></ul><h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><ul><li><p>DatagramSocket:UDP的发送端和接收段对象</p><ul><li>void send(DatagramPacket dp):发送数据包</li><li>void receive(DatagramPacket dp):接收数据包</li></ul></li><li><p>DatagramPacket:数据包对象</p><ul><li>发送端对象：DatagramPacket(byte buf[], int length,InetAddress address, int port)</li><li>接收段对象：DatagramPacket(byte buf[], int length)</li></ul></li><li><p>列子</p><ul><li>发送端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户发送端========================&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建发送端对象（发送端自带默认端口号）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2创建一个数据包对象封装数据</span></span><br><span class="line">        <span class="type">byte</span>[] sData = <span class="string">&quot;你好，我是JY&quot;</span>.getBytes();<span class="comment">//要发送的数据</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参数一：要发送的数据</span></span><br><span class="line"><span class="comment">        参数二：发送数据的大小</span></span><br><span class="line"><span class="comment">        参数三：接收端的IP地址</span></span><br><span class="line"><span class="comment">        参数四：接收端的端口</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(sData, sData.length, InetAddress.getLocalHost(),<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.发送数据出去</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Serverg1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务接受端=======================&quot;</span>);</span><br><span class="line">        <span class="comment">//1.创建接收端对象，注册端口号</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建一个数据包对象接收数据</span></span><br><span class="line">        <span class="type">byte</span> [] rData= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(rData,rData.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.等待接收数据</span></span><br><span class="line">        server.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取接收数据的大小，并输出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dataLenth</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line">        <span class="type">String</span> <span class="variable">strData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(rData,<span class="number">0</span>,dataLenth);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到了:&quot;</span>+strData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h2><ul><li>概念：JDBC就是使用Java语言操作关系型数据库的一套API，全称：( Java DataBase Connectivity ) Java数据库连接。</li><li>本质：官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。</li></ul><h2 id="快速入门步骤"><a href="#快速入门步骤" class="headerlink" title="快速入门步骤"></a>快速入门步骤</h2><ol start="0"><li><p>创建工程，导入驱动jar包</p></li><li><p>注册驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//在mysql 5之后的驱动jar包可以不做这一步</span></span><br></pre></td></tr></table></figure></li><li><p>获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure></li><li><p>定义sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;要执行的sql语句&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>获取执行sql对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement();</span><br></pre></td></tr></table></figure></li><li><p>执行sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeQuery(<span class="keyword">sql</span>);</span><br></pre></td></tr></table></figure></li><li><p>处理返回结果</p></li><li><p>释放资源</p></li></ol><h2 id="JDBC-API详解"><a href="#JDBC-API详解" class="headerlink" title="JDBC API详解"></a>JDBC API详解</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><ul><li>作用：注册驱动、获取数据库连接</li></ul><ol><li><p>注册驱动：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<span class="operator">/</span><span class="operator">/</span>在mysql <span class="number">5</span>之后的驱动jar包可以不做这一步</span><br></pre></td></tr></table></figure></li><li><p>获取连接：</p><ul><li><p>Connection getConnection(Strng url,String user,String password)</p></li><li><p>参数url语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2…</p></li><li><p>可配置useSSL&#x3D;false参数，禁用安全连接方式，解决警告提示。</p></li></ul></li></ol><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul><li>作用：获取执行sql的对象、管理事务</li></ul><ol><li>获取执行sql的对象<ul><li>普通执行sql对象：Statement createStatement()</li><li>预编译SQL的执行SQL对象:防止SQL注入：PrepareStatement  prepareStatement(sql)</li><li>执行存储过程的对象：CallableStatement prepareCall(sql)</li></ul></li><li>管理事务<ol><li>开启事务：setAutoCommit(boolean autoCommit)：true为自动提交事务;false为手动提交事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ol></li></ol><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><ul><li><p>作用：执行sql语句</p></li><li><p>执行DML、DDL语句：int executeUpdate(sql)</p><ul><li>DML语句返回值：DML语句影响的行数（DML）</li><li>DDL语句返回值：DDL语句执行后，执行成功也可能返回0</li></ul></li><li><p>执行DQL语句：ResultSet executeQuery(sql)</p><ul><li>返回值：ResultSet结果集对象</li></ul></li></ul><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><ul><li>作用：封装DQL查询语句的结果</li><li>boolean next()<ul><li>常跟着循环一起使用</li><li>改方法会将光标从当前位置向下移动一行，并判断当前行是否为有效行</li></ul></li><li>xxx getXxx(参数)<ul><li>xxx指的是数据类型，根据需求写。</li><li>如：int getInt(参数)和String getString(参数)</li></ul></li></ul><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><ul><li>作用：预编译SQL并执行SQL语句</li></ul><ol><li><p>获取PreparedStatement对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrepareStatement</span> <span class="variable">prst</span> <span class="operator">=</span> con.prepareStatemnt(sql); <span class="comment">//sql语句中的参数值用？代替</span></span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prst.setXxx(参数<span class="number">1</span>，参数<span class="number">2</span>);</span><br><span class="line"><span class="comment">//Xxx指的是数据类型，参数1是sql语句中?的位置编号，参数2是要设给？的值</span></span><br></pre></td></tr></table></figure></li><li><p>执行sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prst.executeUpdate()或executeQuery();</span><br></pre></td></tr></table></figure></li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>介绍</p><ul><li>数据结构是计算机底层存储、组织数据的方式。</li><li>是指数据相互之间是以什么方式排列在一起的。</li><li>数据结构是为了更加方便的管理和使用数据，需要结合具体的业务场景来进行选择。</li><li>一般情况下，精心选择的数据结构可以带来更高的运行或者存储效率。</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301731138.png" alt="image-20240312204540277"></p><p>特点</p><ul><li>先进后出，后进先出</li><li>数据进入栈模型的过程称为：压&#x2F;进栈</li><li>数据离开栈模型的过程称为：弹&#x2F;出栈</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732817.png" alt="image-20240312204620758"></p><p>特点</p><ul><li>先进先出，后进后出</li><li>数据从后端进入队列模型的过程称为：入队列</li><li>数据从前端离开队列模型的过程称为：出队列</li></ul><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>特点</p><ul><li>查询快：查询数据通过地址值和索引定位，查询任意数据耗时相同。(元素在内存中是<em><strong>连续</strong></em>存储的)</li><li>删除慢：要将原始数据删除，同时后面每个数据前移。</li><li>添加慢：添加位置后的每个数据后移，再添加元素。</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>单向链表</p><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732721.png" alt="image-20240312211111795"></p><p>双向链表</p><p><img src="https://gitee.com/lujiaye/picture-bed/raw/master/img/202403122111336.png" alt="image-20240312211143209"></p><p>特点</p><ul><li>链表中的结点是独立的对象，在内存中是<em><strong>不连续</strong></em>的，每个结点包含数据值和下一个结点的地址。</li><li>链表<em><strong>查询慢</strong></em>，无论查询哪个数据都要从头开始找。</li><li>链表<em><strong>增删相对快</strong></em></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。</li><li><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</li><li><strong>回溯法解决的问题都可以抽象为树形结构</strong>，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</li></ul><p>回溯三部曲</p><ol><li>回溯函数模板返回值以及参数</li><li>回溯函数终止条件</li><li>回溯搜索的遍历过程</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>组合问题</li><li>排列问题</li><li>切割问题</li><li>子集问题</li><li>棋盘问题（N皇后、解数独）</li></ul><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732546.png" alt="image-20240405221811922"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入: [1,2,3]</span></span><br><span class="line"><span class="comment"> * 输出: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">paiLie1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; listpath = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> used[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrs = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">boolean</span>[arrs.length];</span><br><span class="line">        backTracking(arrs);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] arrs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arrs.length==listpath.size())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(listpath));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i]=<span class="literal">true</span>;</span><br><span class="line">            listpath.add(arrs[i]);</span><br><span class="line">            backTracking(arrs);</span><br><span class="line">            listpath.remove(listpath.size()-<span class="number">1</span>);</span><br><span class="line">            used[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><p><img src="https://jy-pictures.oss-cn-beijing.aliyuncs.com/undefined202404301732470.png" alt="image-20240405223050408"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">zuHe1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; result= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; path= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>startIndex;i&lt;=n;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="理论基础-1"><a href="#理论基础-1" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</li><li>贪心没有套路，说白了就是常识性推导加上举反例。</li></ul><p>贪心四部曲</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="理论基础-2"><a href="#理论基础-2" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</li><li>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的</li></ul><p>动态规划五部曲</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h3 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>背包问题</li><li>路径问题</li><li>爬楼梯问题</li><li>股票问题</li><li>子序列问题</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="重复子串"><a href="#重复子串" class="headerlink" title="重复子串"></a>重复子串</h3><p>问题：判断一个字符串，能否由它的一个子串重复多次构成，如：</p><ul><li>输入”abab“，输出true</li><li>输入”aba“，输出false</li></ul><p>解法一（移动匹配法）</p><ul><li>将原字符串*2，再去头去尾得到一个新的字符串，如果新字符串还包含原字符串则为true，否则为false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bu.readLine();</span><br><span class="line">        String str2= str+str;</span><br><span class="line">        str2=str2.substring(<span class="number">1</span>,str2.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str2.contains(str))&#123;</span><br><span class="line">            System.out.println(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二（KMP算法）</p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>字符串替换可以用正则表达式来做如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=str.replaceAll(&quot;a&#123;10,&#125;&quot;, &quot;b&quot;); //用b来替换str中全部超过9个连续的a</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;jybzzz&quot;</span>;</span><br><span class="line"><span class="comment">//1.反转字符串:用StringBuilder类中的reverse()</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str1).reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1字符串的比较:compareTo(str)</span></span><br><span class="line"><span class="comment">//先按照字典次序大小比较，如果出现不等的字符，直接返回这两个字符的大小差值。</span></span><br><span class="line">String str3=<span class="string">&quot;help&quot;</span>;</span><br><span class="line">String str4=<span class="string">&quot;hell&quot;</span>;</span><br><span class="line">System.out.println(str3.compareTo(str4));<span class="comment">//打印4，p与l的字符大小差值</span></span><br><span class="line"><span class="comment">//如果前k个字符都相等，只是长度不同，那么返回两个字符串长度差值。</span></span><br><span class="line">String str5=<span class="string">&quot;help me&quot;</span>;</span><br><span class="line">System.out.println(str3.compareTo(str5));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.字符串的查找</span></span><br><span class="line"><span class="comment">//charAt(int index):此方法返回index位置上的字符</span></span><br><span class="line">System.out.println(str1.charAt(<span class="number">3</span>));</span><br><span class="line"><span class="comment">//indexOf(String str):此方法为返回str第一次出现的位置</span></span><br><span class="line">System.out.println(str1.indexOf(<span class="string">&quot;zzz&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.字符串的转换</span></span><br><span class="line"><span class="comment">//转数字:Integer.parseInt(str)</span></span><br><span class="line">String str6=<span class="string">&quot;12345&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转数字:&quot;</span>+Integer.parseInt(str6));</span><br><span class="line"><span class="comment">//转数组：toCharArray()</span></span><br><span class="line"><span class="type">char</span>[] chars = str1.toCharArray();</span><br><span class="line">System.out.println(<span class="string">&quot;字符串转数组:&quot;</span>+Arrays.toString(chars));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.字符串的替换</span></span><br><span class="line">String str7=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//replaceAll(str1,str2):将字符串中的全部str1替换成str2</span></span><br><span class="line">System.out.println(str7.replaceAll(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>));</span><br><span class="line"><span class="comment">//replaceAll(str1,str2):将字符串中的第一个str1替换成str2</span></span><br><span class="line">System.out.println(str7.replaceFirst(<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.字符串拆分:split(str)</span></span><br><span class="line">String str8=<span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">String[] os = str8.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(os));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.字符串截取:substring(int start,int end)   注：左闭右开</span></span><br><span class="line">System.out.println(str1.substring(<span class="number">1</span>,str1.length()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.大小写转换</span></span><br><span class="line">String str9=<span class="string">&quot;JyBzZz&quot;</span>;</span><br><span class="line"><span class="comment">//将字符串全部变为小写:toLowerCase()</span></span><br><span class="line">System.out.println(str9.toLowerCase());</span><br><span class="line"><span class="comment">//将字符串全部变为大写:toUpperCase()</span></span><br><span class="line">System.out.println(str9.toUpperCase());</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.字符串去空格</span></span><br><span class="line"><span class="comment">//去掉字符串中的左右空格,保留中间空格:trim()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str10</span> <span class="operator">=</span> <span class="string">&quot;    j y b z z z    &quot;</span>;</span><br><span class="line">System.out.println(str10.trim());</span><br><span class="line"><span class="comment">//去掉全部空格：replaceAll(&quot; &quot;,&quot;&quot;)</span></span><br><span class="line">System.out.println(str10.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>字符串转数字<ul><li>Interger.parseInt(str)</li></ul></li><li>数组转List集合<ul><li>Arrays.<strong>asList</strong>(arr)</li></ul></li><li>集合转数组<ul><li>arr.<strong>toArray</strong>()</li></ul></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><p>数组</p><ul><li>升序：Arrays.sort(array);</li></ul></li><li><p>集合</p><ul><li>升序：Collections.sort(list);</li><li>降序（先升序再reverse)：Collections.reverse(list);</li></ul></li><li><p>自定义对象按某个属性排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">22</span>));</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>));</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">25</span>));</span><br><span class="line">studentList.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;David&quot;</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">Collections.sort(studentList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.getAge()-s2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组集合"><a href="#数组集合" class="headerlink" title="数组集合"></a>数组集合</h2><p>数组</p><ul><li><p>数组截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(原始数组,截取的开始位置,截取后的新数组,<span class="number">0</span>,截取的长度);</span><br></pre></td></tr></table></figure></li><li><p>数组求和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(数组名).sum()</span><br></pre></td></tr></table></figure></li><li><p>数组求最大值最小值平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最大值：Arrays.stream(arr).max().getAsInt()</span><br><span class="line">最小值：Arrays.stream(arr).min().getAsInt()</span><br><span class="line">平均值：Arrays.stream(arr).average().getAsDouble()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> * 取整运算</span><br><span class="line"> */</span><br><span class="line"><span class="comment">//        1、四舍五入round</span></span><br><span class="line">        <span class="type">int</span> num1=Math.round(<span class="number">3.4f</span>);</span><br><span class="line">        System.out.println(num1);</span><br><span class="line"><span class="comment">//  2.String.format() </span></span><br><span class="line">String.format(<span class="string">&quot;%.要保留的小数位数f&quot;</span>,num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2.向上取整ceil</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> Math.ceil(<span class="number">3.5f</span>);</span><br><span class="line">        System.out.println((<span class="type">int</span>)num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        3.向下取整floor</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num3</span> <span class="operator">=</span> Math.floor(<span class="number">3.5</span>);</span><br><span class="line">        System.out.println((<span class="type">int</span>)num3);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指数运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//        1.返回以a为底数，以b为指数的幂值pow</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num4</span> <span class="operator">=</span> Math.pow(<span class="number">16</span>,<span class="number">0.5</span>);</span><br><span class="line">        System.out.println(num4);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        1.返回大于等于 0.0、小于 1.0 的 double 类型随机数random</span></span><br><span class="line">        <span class="type">double</span> numran=Math.random();</span><br><span class="line">        System.out.println(numran);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3.5</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%.2f&quot;</span>,num);</span><br></pre></td></tr></table></figure><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><pre><code> BigDecimal类是Java中提供的一个用于精确计算和表示任意精度的十进制数的类</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title function_">valueOf</span><span class="params">(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal b)</span>加法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal b)</span>减法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal b)</span>乘法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal b)</span>除法</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(另一个BigDecimal对象，精确几位，舍入模式)</span>除法</span><br></pre></td></tr></table></figure><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li><p>equals和&#x3D;&#x3D;</p><ul><li>“&#x3D;&#x3D;”是运算符，如果是基本数据类型，则比较存储的值；如果是引用数据类型，则比较所指向对象的地址值。</li><li>quals是Object的方法，默认比较的是对象的地址值。可以通过重写从而比较的对象的值。如String</li></ul></li><li><p><code>classpath</code> 和 <code>path</code> 环境变量的查看与配置的方式完全相同。</p></li><li><p>synchronized 关键字有同步代码块和同步方法2 种</p></li><li><p>默认的 <code>equals()</code> 方法在比较两个对象时，使用的是引用比较，而String中的equals方法使用的是值比较。</p></li><li><p>对于基本数据类型&#x3D;&#x3D;是值比较，对于引用数据类型&#x3D;&#x3D;是引用比较</p></li><li><p>对于String s1&#x3D;”abc”，”abc“是放在方法区中的字符串常量池里面，它是可以共享和重用的。而对于String s1&#x3D;new String(“abc”)，”abc“是放在堆内存中的。</p></li><li><p>StringBuilder的equals用的是默认的比较方式。</p></li><li><p>StringBuilde是非线程安全的，StringBuffer是线程安全的</p></li><li><p>Arraylist是非线程安全的，Vector是线程安全的</p></li><li><p>HashMap是非线程安全的，HashTables是线程安全的</p></li><li><p>堆内存是唯一的，而每个线程都有自己的栈内存</p></li><li><p>File 对象既可以表示文件，也可以表示目录，它可以查出与文件相关的信息，<strong>不包括文件内容</strong>。</p></li><li><p>super(参数)：调用父类中的某一个<strong>构造器</strong></p></li><li><p>局部变量在使用前必须被初始化，成员变量不用。</p></li><li><p>switch</p><ul><li>后面的小括号只能是基本数据类型和String、enum</li><li>匹配哪一个case就从哪一个位置向下执行，直到遇到了break或者整体结束为止</li><li>case后面的数值不可以重复</li></ul></li><li><p>Java中的自动装箱是指：自动将基本数据类型转换为对应的包装类对象。</p></li><li><p>静态方法</p><ul><li><strong>静态方法只能访问静态成员和方法，不可以“直接”访问实例成员和方法</strong></li><li>静态方法属于类而不属于实例，是不能被实例化的方法。</li></ul></li><li><p>断言是一种用于验证程序中的条件是否为真的机制，通常用于调试和测试阶段。</p></li><li><p>线程是一种用于<strong>并发</strong>执行的单元，可以同时运行多个线程实现多任务。</p></li><li><p>布尔类型不能被强制类型转换为其他数据类型</p></li></ul><h1 id="Idea快捷键"><a href="#Idea快捷键" class="headerlink" title="Idea快捷键"></a>Idea快捷键</h1><ul><li>alt+insert：构造器、GetSet方法、ToString、equals() and hashCode()快速生成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
